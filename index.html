<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Image Board</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            background-color: #f0e0d6;
            color: #000;
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 12px;
        }

        ::-webkit-scrollbar-track {
            background: #e0d0c0;
        }

        ::-webkit-scrollbar-thumb {
            background: #9ed2f5;
            border-radius: 6px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #7ab8db;
        }

        /* Header */
        .header {
            background-color: #9ed2f5;
            padding: 10px 15px;
            border-bottom: 1px solid #7ab8db;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
    font-size: 18px;
    font-weight: bold;
    color: #0600ff;
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
}

        .menu-btn {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
        }

        .logout-btn {
            background: none;
            border: none;
            font-size: 14px;
            cursor: pointer;
            text-decoration: underline;
        }

        /* Sidebar */
        .sidebar {
            position: fixed;
            top: 0;
            left: -250px;
            width: 250px;
            height: 100%;
            background-color: #eee;
            border-right: 1px solid #ccc;
            transition: left 0.3s;
            z-index: 1000;
            overflow-y: auto;
        }

        .sidebar.open {
            left: 0;
        }

        .sidebar-header {
            padding: 15px;
            background-color: #9ed2f5;
            border-bottom: 1px solid #7ab8db;
        }

        .sidebar-close {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            float: right;
        }

        .sidebar-content {
            padding: 15px;
        }

        .sidebar-section {
            margin-bottom: 20px;
        }

        .sidebar-section h3 {
            font-size: 14px;
            margin-bottom: 10px;
            color: #555;
        }

        .sidebar-section a {
            display: block;
            padding: 8px 0;
            color: #000;
            text-decoration: none;
            font-size: 14px;
        }

        .sidebar-section a:hover {
            text-decoration: underline;
        }

        /* Overlay */
        .overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 999;
        }

        .overlay.active {
            display: block;
        }

        /* Main Content */
        .container {
            padding: 15px 10px;
        }

        .page-title {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 15px;
            padding-left: 5px;
        }

        /* Image Grid */
        .image-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 2px;
        }

        .image-item {
            aspect-ratio: 3 / 4;
            background-color: #ddd;
            position: relative;
            overflow: hidden;
            transition: all 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
        }

        .image-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            -webkit-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
        }

        .image-item.dragging {
            opacity: 0.9;
            box-shadow: 0 10px 30px rgba(0,0,0,0.4);
            will-change: transform;
            transition: none !important;
        }

        .image-item.drag-over {
            /* No visual feedback - cleaner look */
        }

        /* Upload Tab */
        .upload-tab {
            position: fixed;
            right: 0;
            bottom: 10px;
            width: 30px;
            height: 60px;
            background-color: #9ed2f5;
            border: 1px solid #7ab8db;
            border-right: none;
            border-radius: 5px 0 0 5px;
            cursor: pointer;
            box-shadow: -2px 2px 5px rgba(0,0,0,0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            color: #000;
            font-weight: bold;
        }

        .container {
            padding: 15px 10px;
            padding-bottom: 20px;
        }

        /* Rules Tab */
        .rules-tab {
            position: fixed;
            right: 0;
            bottom: 150px;
            width: 30px;
            height: 60px;
            background-color: #d4c5b0;
            border: 1px solid #b8a890;
            border-right: none;
            border-radius: 5px 0 0 5px;
            cursor: pointer;
            box-shadow: -2px 2px 5px rgba(0,0,0,0.2);
        }

        /* Chat Tab */
        .chat-tab {
            position: fixed;
            right: 0;
            bottom: 80px;
            width: 30px;
            height: 60px;
            background-color: #b8a890;
            border: 1px solid #a0927d;
            border-right: none;
            border-radius: 5px 0 0 5px;
            cursor: pointer;
            box-shadow: -2px 2px 5px rgba(0,0,0,0.2);
            display: none;
        }

        .chat-tab.unlocked {
            display: block;
        }

        /* Chatbox */
        .chatbox {
            position: fixed;
            bottom: -100%;
            left: 0;
            right: 0;
            height: 40%;
            background-color: #f5f5dc;
            border-top: 2px solid #8b7355;
            transition: bottom 0.3s ease;
            z-index: 2000;
            display: flex;
            flex-direction: column;
            font-family: 'Courier New', Courier, monospace;
        }

        .chatbox.open {
            bottom: 0;
        }

        .chatbox-header {
            background-color: #d4c5b0;
            padding: 10px 15px;
            border-bottom: 1px solid #8b7355;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .chatbox-header h3 {
            font-family: 'Courier New', Courier, monospace;
            font-size: 14px;
            margin: 0;
        }

        .chatbox-minimize {
            background: none;
            border: none;
            font-size: 18px;
            cursor: pointer;
        }

        .chatbox-messages {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
            background-color: #fff;
        }

        .chat-message {
            margin-bottom: 10px;
            font-size: 13px;
            line-height: 1.6;
        }

        .chat-message.own {
            text-align: right;
        }

        .chat-message .username {
            font-weight: bold;
        }

        .clickable-username {
            cursor: pointer;
            text-decoration: underline;
        }

        .clickable-username:hover {
            opacity: 0.7;
        }

        .chat-message.own .username {
            /* Color set dynamically based on upload count */
        }

        .chat-message .username {
            /* Color set dynamically based on upload count */
        }

        .chatbox-input {
            display: flex;
            padding: 10px;
            background-color: #f5f5dc;
            border-top: 1px solid #8b7355;
        }

        .chatbox-input input {
            flex: 1;
            padding: 8px;
            border: 1px solid #8b7355;
            font-family: 'Courier New', Courier, monospace;
            font-size: 13px;
        }

        .chatbox-input button {
            padding: 8px 15px;
            margin-left: 5px;
            background-color: #d4c5b0;
            border: 1px solid #8b7355;
            font-family: 'Courier New', Courier, monospace;
            cursor: pointer;
        }

        /* Chat unlock modal */
        .chat-unlock-content {
            background-color: #f5f5dc;
            padding: 30px;
            border: 2px solid #8b7355;
            width: 90%;
            max-width: 400px;
            font-family: 'Courier New', Courier, monospace;
        }

        .chat-unlock-content h2 {
            font-family: 'Courier New', Courier, monospace;
            margin-bottom: 20px;
            font-size: 16px;
        }

        .chat-unlock-content input {
            width: 100%;
            padding: 10px;
            margin-bottom: 15px;
            border: 1px solid #8b7355;
            font-family: 'Courier New', Courier, monospace;
            font-size: 13px;
        }

        .chat-unlock-content button {
            width: 100%;
            padding: 10px;
            background-color: #d4c5b0;
            border: 1px solid #8b7355;
            font-family: 'Courier New', Courier, monospace;
            cursor: pointer;
        }

        /* Rules Modal */
        .rules-modal-content {
            background-color: #f5f5dc;
            padding: 30px;
            border: 2px solid #8b7355;
            width: 90%;
            max-width: 400px;
            font-family: 'Courier New', Courier, monospace;
        }

        .rules-modal-content h2 {
            font-family: 'Courier New', Courier, monospace;
            margin-bottom: 20px;
            font-size: 18px;
            text-align: center;
        }

        .rules-modal-content p {
            font-family: 'Courier New', Courier, monospace;
            font-size: 13px;
            line-height: 1.8;
            margin-bottom: 15px;
        }

        .rules-modal-content button {
            font-family: 'Courier New', Courier, monospace;
        }

        /* Collection Picker Modal */
        .collection-picker-content {
            background-color: #eee;
            padding: 0;
            border: 1px solid #ccc;
            width: 280px;
            max-width: 85%;
            font-family: 'Courier New', Courier, monospace;
            max-height: 60vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .collection-picker-header {
            background-color: #9ed2f5;
            padding: 12px 15px;
            border-bottom: 1px solid #7ab8db;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .collection-picker-header h2 {
            font-family: 'Courier New', Courier, monospace;
            font-size: 14px;
            margin: 0;
            color: #000;
        }

        .collection-picker-close {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            line-height: 1;
        }

        .collection-picker-content input {
            width: calc(100% - 20px);
            padding: 8px 10px;
            margin: 10px;
            border: 1px solid #ccc;
            background-color: #fff;
            font-family: 'Courier New', Courier, monospace;
            font-size: 12px;
        }

        .collection-list {
            flex: 1;
            overflow-y: auto;
            padding: 0 10px 10px 10px;
        }

        .collection-item {
            padding: 10px;
            border-bottom: 1px solid #ddd;
            cursor: pointer;
            background-color: #fff;
            font-family: 'Courier New', Courier, monospace;
            font-size: 13px;
            margin-bottom: 5px;
        }

        .collection-item:hover {
            background-color: #f5f5f5;
        }

        /* Secret Secret Rules */
        .secret-secret-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: url('stars-bg.jpg') center center;
            background-size: cover;
            z-index: 3000;
            animation: fadeIn 1s ease-in;
        }

        .secret-secret-overlay.active {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .secret-secret-content {
            background-color: rgba(255, 255, 255, 0.95);
            padding: 30px;
            border: 2px solid #fff;
            box-shadow: 0 0 30px rgba(255, 255, 255, 0.3);
            width: 85%;
            max-width: 400px;
            font-family: 'Courier New', Courier, monospace;
            animation: popIn 0.5s ease-out 0.5s both;
            max-height: 80vh;
            overflow-y: auto;
        }

        .secret-secret-content h2 {
            font-family: 'Courier New', Courier, monospace;
            margin-bottom: 20px;
            font-size: 18px;
            text-align: center;
            color: #000;
        }

        .secret-secret-content p {
            font-family: 'Courier New', Courier, monospace;
            font-size: 13px;
            line-height: 1.8;
            margin-bottom: 15px;
            color: #000;
        }

        .secret-secret-content button {
            font-family: 'Courier New', Courier, monospace;
            width: 100%;
            background-color: #000;
            color: #fff;
            padding: 10px;
            border: 1px solid #000;
            cursor: pointer;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        @keyframes popIn {
            from {
                transform: scale(0.8);
                opacity: 0;
            }
            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        /* Clickable secret words */
        .clickable-secret {
            cursor: pointer;
            position: relative;
        }

        .clickable-secret:hover {
            opacity: 0.7;
        }

        /* Login Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #f0e0d6;
            z-index: 2000;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .modal-content {
            background: white;
            border: 3px solid #0600ff;
            padding: 40px;
            box-shadow: 8px 8px 0px #0600ff;
            width: 100%;
            max-width: 500px;
        }

        .modal-content h2 {
            text-align: center;
            color: #0600ff;
            font-size: 32px;
            margin-bottom: 10px;
            text-transform: lowercase;
            letter-spacing: 2px;
            font-family: 'Courier New', Courier, monospace;
        }

        .modal-tagline {
            text-align: center;
            color: #666;
            font-size: 12px;
            margin-bottom: 20px;
            font-family: 'Courier New', Courier, monospace;
        }

        .decorative-line {
            height: 3px;
            background: linear-gradient(90deg, #0600ff, #9ed2f5, #0600ff);
            margin: 20px 0;
        }

        .modal-content input {
            width: 100%;
            padding: 12px;
            margin-bottom: 15px;
            border: 2px solid #0600ff;
            background: #fff;
            font-family: 'Courier New', Courier, monospace;
            font-size: 14px;
            transition: all 0.3s;
        }

        .modal-content input:focus {
            outline: none;
            background: #9ed2f5;
            border-color: #0600ff;
        }

        .modal-content button {
            width: 100%;
            padding: 15px;
            border: 2px solid #0600ff;
            background: #0600ff;
            color: white;
            font-family: 'Courier New', Courier, monospace;
            font-size: 14px;
            cursor: pointer;
            text-transform: lowercase;
            transition: all 0.3s;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .modal-content button:hover {
            background: white;
            color: #0600ff;
        }

        .modal-content p {
            margin-top: 15px;
            font-size: 12px;
            text-align: center;
            font-family: 'Courier New', Courier, monospace;
        }

        .modal-content a {
            color: #0600ff;
            text-decoration: none;
        }

        .modal-content a:hover {
            text-decoration: underline;
        }

        @media (max-width: 600px) {
            .modal-content {
                padding: 30px 20px;
                box-shadow: 5px 5px 0px #0600ff;
            }

            .modal-content h2 {
                font-size: 24px;
            }
        }

        /* Crop Modal */
        #cropModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 3000;
            justify-content: center;
            align-items: center;
        }

        .crop-container {
            max-width: 90%;
            max-height: 90%;
            text-align: center;
        }

        .crop-area {
            position: relative;
            display: inline-block;
            max-width: 100%;
            max-height: 70vh;
        }

        .crop-area img {
            max-width: 100%;
            max-height: 70vh;
            display: block;
        }

        .crop-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .crop-box {
            position: absolute;
            border: 2px solid #0600ff;
            box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.5);
            cursor: move;
        }

        .crop-controls {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .crop-controls button {
            padding: 12px 24px;
            background: #0600ff;
            color: white;
            border: 2px solid #0600ff;
            cursor: pointer;
            font-family: 'Courier New', Courier, monospace;
            font-size: 14px;
            transition: all 0.3s;
        }

        .crop-controls button:hover {
            background: white;
            color: #0600ff;
        }

        .crop-controls button.cancel {
            background: #666;
            border-color: #666;
        }

        .crop-controls button.cancel:hover {
            background: white;
            color: #666;
        }
        /* Tags for image detail modal */
.tag-pill {
    background-color: #d4c5b0;
    color: #000;
    padding: 6px 12px;
    border-radius: 3px;
    font-size: 11px;
    font-family: 'Courier New', Courier, monospace;
    border: 1px solid #8b7355;
    display: inline-block;
}

.tag-pill:hover {
    background-color: #c9b5a0;
}
    </style>
</head>
<body>
  <!-- Header -->
    <div class="header">
        <button class="menu-btn" onclick="toggleSidebar()">‚ò∞</button>
        <h1>image board</h1>
        <div style="display: flex; align-items: center; gap: 15px;">
            <a href="#" onclick="loadAccountSettings(); return false;" id="accountLink" style="display: none; text-decoration: none; font-size: 18px; color: #000;">@</a>
            <button class="logout-btn" id="logoutBtn" onclick="handleLogout()" style="display: none;">logout</button>
        </div>
    </div>

    <!-- Sidebar -->
    <div class="sidebar" id="sidebar">
        <div class="sidebar-header">
            <button class="sidebar-close" onclick="toggleSidebar()">√ó</button>
            <h2 style="font-size: 16px;">boards</h2>
        </div>
        <div class="sidebar-content">
            <div class="sidebar-section">
                <h3>MAIN</h3>
                <a href="#" onclick="loadPage('everything')">/ everything</a>
                <a href="#" onclick="loadMyProfile()">/ my profile</a>
            </div>
            <div class="sidebar-section">
                <h3>COLLECTIONS</h3>
                <div id="collectionsList">
                    <!-- Collections will load here -->
                </div>
                <a href="#" onclick="createNewCollection()" style="color: #666; font-style: italic;">+ create new</a>
            </div>
        </div>
    </div>

    <!-- Overlay -->
    <div class="overlay" id="overlay" onclick="toggleSidebar()"></div>

    <!-- Main Content -->
    <div class="container">
        <div class="page-title" id="pageTitle">/ everything</div>
        <div class="image-grid" id="imageGrid">
            <!-- Placeholder images -->
            <div class="image-item" style="background-color: #c9b5a0;"></div>
            <div class="image-item" style="background-color: #d4c4b0;"></div>
            <div class="image-item" style="background-color: #b5a596;"></div>
            <div class="image-item" style="background-color: #cbb8a5;"></div>
            <div class="image-item" style="background-color: #a89787;"></div>
            <div class="image-item" style="background-color: #d1bfad;"></div>
            <div class="image-item" style="background-color: #baa999;"></div>
            <div class="image-item" style="background-color: #c5b3a2;"></div>
            <div class="image-item" style="background-color: #aea093;"></div>
            <div class="image-item" style="background-color: #d0beac;"></div>
            <div class="image-item" style="background-color: #b9a898;"></div>
            <div class="image-item" style="background-color: #c4b2a1;"></div>
            <div class="image-item" style="background-color: #ad9f92;"></div>
            <div class="image-item" style="background-color: #cfbdab;"></div>
            <div class="image-item" style="background-color: #b8a797;"></div>
        </div>
    </div>

    <!-- Upload Tab -->
    <div class="upload-tab" onclick="openUploadModal()">+</div>

    <!-- Rules Tab -->
    <div class="rules-tab" onclick="openRulesModal()"></div>

    <!-- Chat Tab -->
    <div class="chat-tab" id="chatTab" onclick="toggleChatbox()"></div>

    <!-- Chatbox -->
    <div class="chatbox" id="chatbox">
        <div class="chatbox-header">
            <h3>secret chat</h3>
            <button class="chatbox-minimize" onclick="toggleChatbox()">_</button>
        </div>
        <div class="chatbox-messages" id="chatMessages">
            <!-- Messages will appear here -->
        </div>
        <div class="chatbox-input">
            <input type="text" id="chatInput" placeholder="type message..." onkeypress="if(event.key==='Enter') sendMessage()">
            <button onclick="sendMessage()">send</button>
        </div>
    </div>

    <!-- Rules Modal -->
    <div class="modal" id="rulesModal">
        <div class="rules-modal-content">
            <h2>* <span class="clickable-secret" onclick="secretWordClicked('title')">secret</span> rules *</h2>
            <p><strong>TO DELETE:</strong><br>Tap top-right corner, then bottom-right corner of your image</p>
            <p><strong>TO ADD TO COLLECTION:</strong><br>Tap top-left corner, then bottom-left corner</p>
            <p><strong>TO OPEN LINK:</strong><br>Tap center of image</p>
            <p><strong>TO REORDER:</strong><br>Hold for 1 second, then drag to new position</p>
            <p><strong>TO SECRET <span class="clickable-secret" onclick="secretWordClicked('body')">SECRET</span> RULES:</strong><br>Three secrets hide in plain sight - tap the first and last</p>
            <button onclick="closeRulesModal()" style="width: 100%; background-color: #d4c5b0; padding: 10px; border: 1px solid #8b7355;">close</button>
        </div>
    </div>

    <!-- Secret Secret Rules Overlay -->
    <div class="secret-secret-overlay" id="secretSecretOverlay">
        <div class="secret-secret-content">
            <h2>‚ú¶ secret secret rules ‚ú¶</h2>
            <p><strong>TO ACCESS SECRET CHAT:</strong><br>Share your favorite lowkey brand</p>
            <div style="display: flex; gap: 5px; margin-bottom: 20px;">
                <input type="text" id="brandInputInline" placeholder="enter brand..." style="flex: 1; padding: 8px; border: 1px solid #000; font-family: 'Courier New', Courier, monospace; font-size: 12px;">
                <button onclick="submitChatUnlockInline()" style="padding: 8px 15px; background-color: #000; color: #fff; border: 1px solid #000; font-family: 'Courier New', Courier, monospace; cursor: pointer;">submit</button>
            </div>
            <p><strong>CHAT RANK COLORS:</strong><br>
            <span style="color: #0600ff;">‚ñ†</span> Beginner (0-9 uploads) 
            <span style="color: #00a86b;">‚ñ†</span> Regular (10-24) 
            <span style="color: #ff0074;">‚ñ†</span> Active (25-49) 
            <span style="color: #ffa500;">‚ñ†</span> Power User (50-99) 
            <span style="background: linear-gradient(90deg, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #8b00ff); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">‚ñ†</span> Legend (100+)</p>
            <button disabled style="margin: 15px 0; padding: 10px 20px; background-color: #ccc; color: #666; border: 1px solid #999; font-family: 'Courier New', Courier, monospace; cursor: not-allowed; width: 100%;">design packages (coming soon)</button>
            <p><strong>HIDDEN EASTER EGG:</strong><br>[Outfit generator riddle coming soon!]</p>
            <button onclick="closeSecretSecretRules()">close</button>
        </div>
    </div>

    <!-- Design Packages Overlay -->
    <div class="design-packages-overlay" id="designPackagesOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 10000; overflow-y: auto;">
        <div style="max-width: 600px; margin: 50px auto; padding: 30px; background: #f0e0d6; border: 2px solid #000; position: relative;">
            <div id="nextUnlockIndicator" style="position: absolute; top: 15px; right: 15px; font-family: 'Courier New', monospace; font-size: 10px; color: #666;"></div>
            
            <h2 style="font-family: 'Courier New', monospace; text-align: center; margin-bottom: 30px; font-size: 18px;">design packages</h2>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 30px;">
                <!-- Tobacco Royale -->
                <div class="package-box" onclick="selectPackage('tobacco-royale')" style="border: 2px solid #000; padding: 20px; text-align: center; cursor: pointer; background: #fff; position: relative;">
                    <div style="font-size: 40px; margin-bottom: 10px;">üéÅ</div>
                    <div style="font-family: 'Courier New', monospace; font-size: 12px;">tobacco royale</div>
                    <div id="lock-tobacco" style="position: absolute; top: 10px; right: 10px; font-size: 20px;">üîí</div>
                </div>
                
                <!-- Princess Peach -->
                <div class="package-box" onclick="selectPackage('princess-peach')" style="border: 2px solid #000; padding: 20px; text-align: center; cursor: pointer; background: #fff; position: relative;">
                    <div style="font-size: 40px; margin-bottom: 10px;">üéÅ</div>
                    <div style="font-family: 'Courier New', monospace; font-size: 12px;">princess peach</div>
                    <div id="lock-princess" style="position: absolute; top: 10px; right: 10px; font-size: 20px;">üîí</div>
                </div>
                
                <!-- Space Cow -->
                <div class="package-box" onclick="selectPackage('space-cow')" style="border: 2px solid #000; padding: 20px; text-align: center; cursor: pointer; background: #fff; position: relative;">
                    <div style="font-size: 40px; margin-bottom: 10px;">üéÅ</div>
                    <div style="font-family: 'Courier New', monospace; font-size: 12px;">space cow</div>
                    <div id="lock-space" style="position: absolute; top: 10px; right: 10px; font-size: 20px;">üîí</div>
                </div>
                
                <!-- Swamp Witch -->
                <div class="package-box" onclick="selectPackage('swamp-witch')" style="border: 2px solid #000; padding: 20px; text-align: center; cursor: pointer; background: #fff; position: relative;">
                    <div style="font-size: 40px; margin-bottom: 10px;">üéÅ</div>
                    <div style="font-family: 'Courier New', monospace; font-size: 12px;">swamp witch</div>
                    <div id="lock-swamp" style="position: absolute; top: 10px; right: 10px; font-size: 20px;">üîí</div>
                </div>
            </div>
            
            <button onclick="closeDesignPackages()" style="width: 100%; padding: 10px; background-color: #000; color: #fff; border: 1px solid #000; font-family: 'Courier New', Courier, monospace; cursor: pointer;">close</button>
        </div>
    </div>

    <!-- Package Customization Overlay -->
    <div class="package-customization-overlay" id="packageCustomizationOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 10001; overflow-y: auto;">
        <div style="max-width: 500px; margin: 50px auto; padding: 30px; background: #f0e0d6; border: 2px solid #000;">
            <h2 id="packageTitle" style="font-family: 'Courier New', monospace; text-align: center; margin-bottom: 20px; font-size: 16px; text-transform: lowercase;"></h2>
            
            <div style="margin-bottom: 20px; display: flex; gap: 10px; justify-content: center;">
                <button id="bgToggleBtn" onclick="setEditModePackage('background')" style="padding: 8px 16px; background: #000; color: #fff; border: 1px solid #000; font-family: 'Courier New', monospace; cursor: pointer; font-size: 11px;">background</button>
                <button id="patternToggleBtn" onclick="setEditModePackage('pattern')" style="padding: 8px 16px; background: #fff; color: #000; border: 1px solid #000; font-family: 'Courier New', monospace; cursor: pointer; font-size: 11px;">pattern</button>
            </div>
            
            <div id="colorGrid" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 0; border: 1px solid #000; margin-bottom: 20px;"></div>
            
            <div style="margin-bottom: 20px; padding: 15px; background: #fff; border: 1px solid #000; text-align: center; font-family: 'Courier New', monospace; font-size: 11px;">
                current bg: <span id="currentBgDisplay">#f0e0d6</span><br>
                current pattern: <span id="currentPatternDisplay">#ffffff</span>
            </div>
            
            <div style="display: flex; gap: 10px;">
                <button onclick="applyTheme()" style="flex: 1; padding: 10px; background-color: #000; color: #fff; border: 1px solid #000; font-family: 'Courier New', Courier, monospace; cursor: pointer; font-size: 11px;">apply theme</button>
                <button onclick="closePackageCustomization()" style="flex: 1; padding: 10px; background-color: #fff; color: #000; border: 1px solid #000; font-family: 'Courier New', Courier, monospace; cursor: pointer; font-size: 11px;">cancel</button>
            </div>
        </div>
    </div>

    <!-- Chat Unlock Modal -->
    <div class="modal" id="chatUnlockModal">
        <div class="chat-unlock-content">
            <h2>unlock secret chat</h2>
            <p style="font-size: 13px; margin-bottom: 15px;">Share your favorite lowkey brand to gain access:</p>
            <input type="text" id="brandInput" placeholder="enter brand name...">
            <button onclick="submitChatUnlock()">submit</button>
            <button onclick="closeChatUnlock()" style="background-color: #ccc; margin-top: 10px;">cancel</button>
        </div>
    </div>

    <!-- Collection Picker Modal -->
    <div class="modal" id="collectionPickerModal">
        <div class="collection-picker-content">
            <div class="collection-picker-header">
                <h2>add to collection</h2>
                <button class="collection-picker-close" onclick="closeCollectionPicker()">√ó</button>
            </div>
            <input type="text" id="collectionSearch" placeholder="search..." oninput="filterCollections()">
            <div class="collection-list" id="collectionPickerList">
                <!-- Collections will load here -->
            </div>
        </div>
    </div>

    <!-- Crop Modal -->
    <div id="cropModal">
        <div class="crop-container">
            <div class="crop-area" id="cropArea">
                <img id="cropImage" src="" alt="Crop preview">
                <div class="crop-overlay">
                    <div class="crop-box" id="cropBox"></div>
                </div>
            </div>
            <div class="crop-controls">
                <button onclick="applyCrop()">crop & continue</button>
                <button class="cancel" onclick="cancelCrop()">cancel</button>
            </div>
        </div>
    </div>

    <!-- Upload Modal -->
    <div class="modal" id="uploadModal">
        <div class="modal-content">
            <h2>upload image</h2>
            <form id="uploadForm">
                <input type="file" id="imageInput" accept="image/*" required style="margin-bottom: 15px;">
                <input type="url" id="linkInput" placeholder="source link (optional)" style="margin-bottom: 15px;">
                <button type="submit">upload</button>
                <button type="button" onclick="closeUploadModal()" style="background-color: #ccc; margin-top: 10px;">cancel</button>
            </form>
        </div>
    </div>

    <!-- Login Modal -->
    <div class="modal" id="loginModal">
        <div class="modal-content">
            <h2 id="authTitle">girlchan</h2>
            <div class="modal-tagline">// your secret thrift sanctuary //</div>
            <div class="decorative-line"></div>
            <form id="authForm">
                <input type="email" id="emailInput" placeholder="email" required>
                <input type="password" id="passwordInput" placeholder="password" required>
                <input type="text" id="usernameInput" placeholder="username" style="display: none;">
                <button type="submit" id="authSubmit">login</button>
                <p id="authSwitch">need an account? <a href="#" onclick="toggleAuthMode(); return false;">sign up</a></p>
            </form>
        </div>
    </div>

    <!-- Firebase SDK -->
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword, onAuthStateChanged, signOut } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js';
        import { getFirestore, collection, addDoc, doc, setDoc, getDoc, getDocs, query, orderBy, updateDoc, arrayUnion, deleteDoc, onSnapshot } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';
        import { getStorage, ref, uploadBytes, getDownloadURL } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-storage.js';

        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyDExgxdLsySYHaQp4UdXaxhQ0zcSAS72g4",
            authDomain: "girl-4chan.firebaseapp.com",
            projectId: "girl-4chan",
            storageBucket: "girl-4chan.firebasestorage.app",
            messagingSenderId: "290973679176",
            appId: "1:290973679176:web:2074819349d9f464ba227d"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const storage = getStorage(app);

        // Admin configuration
const ADMIN_USER_ID = 'D3nHi7OKBMU583Ibr2koBAVdxsB2';

function isAdmin() {
    return auth.currentUser && auth.currentUser.uid === ADMIN_USER_ID;
}


        // Global variables
        let currentUser = null;
        let isSignupMode = false;
        let currentContext = { type: 'everything', id: null }; // Start on everything page
        let navigationHistory = []; // Stack of previous pages
        let activeTagFilters = []; // Track active tag filters for multi-tag filtering

        // AI Tagging Configuration

        
        const MASTER_TAG_LIST = [
            // Item types - tops
            'baby-tee', 'tank-top', 'crop-top', 'halter-top', 'tube-top', 'butterfly-top',
            'hoodie', 'cardigan', 'sweater', 'blazer', 'jacket', 'corset', 'bodysuit',
            'long-sleeve-top', 'graphic-tee', 'turtleneck', 'polo', 'zip-up',
            
            // Item types - bottoms
            'low-rise-jeans', 'cargo-pants', 'mini-skirt', 'maxi-skirt', 'midi-skirt',
            'pleated-skirt', 'denim-skirt', 'flare-jeans', 'baggy-jeans', 'shorts',
            'yoga-pants', 'leggings', 'sweatpants', 'track-pants', 'bike-shorts',
            'wide-leg-pants', 'straight-leg-jeans', 'skinny-jeans', 'mom-jeans',
            
            // Item types - dresses & one-pieces
            'mini-dress', 'midi-dress', 'maxi-dress', 'slip-dress', 'sundress',
            'party-dress', 'bodycon-dress', 'babydoll-dress', 'romper', 'jumpsuit',
            
            // Item types - shoes & accessories
            'platform-shoes', 'heels', 'sneakers', 'boots', 'mary-janes', 'ballet-flats',
            'bag', 'belt', 'sunglasses', 'jewelry', 'hair-clip',
            
            // Aesthetics & eras
            'y2k', 'grunge', 'coquette', 'cottagecore', 'mcbling', 'indie-sleaze',
            'cyber-y2k', 'streetwear', '90s', '00s', 'vintage', 'preppy', 'goth',
            
            // Details & materials
            'rhinestones', 'lace', 'distressed', 'graphic-print', 'butterfly',
            'velvet', 'mesh', 'sequins', 'denim', 'leather', 'satin', 'knit',
            'fur-trim', 'ruffles', 'cutout', 'tie-dye', 'plaid', 'floral',
            
            // Colors
            'pink', 'baby-blue', 'black', 'white', 'hot-pink', 'lavender',
            'lime-green', 'silver', 'gold', 'red', 'purple', 'yellow', 'brown',
            'grey', 'orange', 'green', 'blue',
            
            // Vibes
            'party', 'casual', 'edgy', 'girly', 'preppy', 'vintage', 'sexy',
            'cute', 'sporty', 'elegant', 'grunge', 'romantic'
        ];

        // Categorized tag structure for filtering
        const TAG_CATEGORIES = {
            Items: [
                'baby-tee', 'tank-top', 'crop-top', 'halter-top', 'tube-top', 'butterfly-top',
                'hoodie', 'cardigan', 'sweater', 'blazer', 'jacket', 'corset', 'bodysuit',
                'long-sleeve-top', 'graphic-tee', 'turtleneck', 'polo', 'zip-up',
                'low-rise-jeans', 'cargo-pants', 'mini-skirt', 'maxi-skirt', 'midi-skirt',
                'pleated-skirt', 'denim-skirt', 'flare-jeans', 'baggy-jeans', 'shorts',
                'yoga-pants', 'leggings', 'sweatpants', 'track-pants', 'bike-shorts',
                'wide-leg-pants', 'straight-leg-jeans', 'skinny-jeans', 'mom-jeans',
                'mini-dress', 'midi-dress', 'maxi-dress', 'slip-dress', 'sundress',
                'party-dress', 'bodycon-dress', 'babydoll-dress', 'romper', 'jumpsuit',
                'platform-shoes', 'heels', 'sneakers', 'boots', 'mary-janes', 'ballet-flats',
                'bag', 'belt', 'sunglasses', 'jewelry', 'hair-clip'
            ],
            Aesthetics: [
                'y2k', 'grunge', 'coquette', 'cottagecore', 'mcbling', 'indie-sleaze',
                'cyber-y2k', 'streetwear', '90s', '00s', 'vintage', 'preppy', 'goth'
            ],
            Details: [
                'rhinestones', 'lace', 'distressed', 'graphic-print', 'butterfly',
                'velvet', 'mesh', 'sequins', 'denim', 'leather', 'satin', 'knit',
                'fur-trim', 'ruffles', 'cutout', 'tie-dye', 'plaid', 'floral'
            ],
            Colors: [
                'pink', 'baby-blue', 'black', 'white', 'hot-pink', 'lavender',
                'lime-green', 'silver', 'gold', 'red', 'purple', 'yellow', 'brown',
                'grey', 'orange', 'green', 'blue'
            ],
            Vibes: [
                'party', 'casual', 'edgy', 'girly', 'preppy', 'vintage', 'sexy',
                'cute', 'sporty', 'elegant', 'grunge', 'romantic'
            ]
        };

        // Helper function to check if a tag is an item type
        function isItemTag(tag) {
            return TAG_CATEGORIES.Items.includes(tag);
        }

       // Check auth state
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                currentUser = user;
                document.getElementById('loginModal').style.display = 'none';
                document.getElementById('logoutBtn').style.display = 'block';
                document.getElementById('accountLink').style.display = 'inline';
                await loadCollections();
                await checkChatUnlock();
                await restoreLastPage(); // Restore the page they were on
            } else {
                document.getElementById('loginModal').style.display = 'flex';
                document.getElementById('logoutBtn').style.display = 'none';
                document.getElementById('accountLink').style.display = 'none';
            }
        });

        // Check if chat is unlocked for this user
        async function checkChatUnlock() {
            try {
                const userDoc = await getDoc(doc(db, 'users', auth.currentUser.uid));
                if (userDoc.exists() && userDoc.data().chatUnlocked) {
                    document.getElementById('chatTab').classList.add('unlocked');
                    loadChatMessages();
                }
            } catch (error) {
                console.error('Error checking chat unlock:', error);
            }
        }

        // AI Tagging Function - calls Netlify backend
        async function getAITags(imageFile) {
            try {
                console.log('Starting AI tagging...');

                // Convert image to base64
                const base64Image = await new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(imageFile);
                });

                console.log('Image converted to base64, calling Netlify function...');

                // Call Netlify function
                const response = await fetch('/.netlify/functions/ai-tagger', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        image: base64Image
                    })
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('AI tagging API error:', response.status, errorText);
                    alert('AI tagging unavailable - image will upload without tags');
                    return [];
                }

                const data = await response.json();
                const tags = Array.isArray(data.tags) ? data.tags : [];
                console.log('AI tags received:', tags);

                if (tags.length === 0) {
                    console.warn('AI returned no tags');
                }

                return tags;
            } catch (error) {
                console.error('Error getting AI tags:', error);
                alert('AI tagging failed - image will upload without tags');
                return [];
            }
        }
// Helper function to get all unique tags from database
async function getAllExistingTags() {
    try {
        const imagesQuery = query(collection(db, 'images'));
        const snapshot = await getDocs(imagesQuery);
        const allTags = new Set();

        snapshot.forEach((doc) => {
            const data = doc.data();
            if (data.tags && Array.isArray(data.tags)) {
                data.tags.forEach(tag => allTags.add(tag));
            }
        });

        return Array.from(allTags).sort();
    } catch (error) {
        console.error('Error fetching tags:', error);
        return [];
    }
}

// Open image detail modal
window.openImageDetail = function(imageId, imageUrl, link, tags) {
    document.getElementById('detailImage').src = imageUrl;
    
    // Display tags
    const tagsContainer = document.getElementById('detailTags');
    tagsContainer.innerHTML = '';
    
    if (tags && tags.length > 0) {
        tags.forEach(tag => {
            const tagEl = document.createElement('span');
            tagEl.className = 'tag-pill';
            tagEl.textContent = tag;
            tagEl.style.cursor = 'pointer';
            tagEl.onclick = () => {
                closeImageDetail();
                loadTagFeed(tag);
            };
            tagsContainer.appendChild(tagEl);
            
            // Admin can delete tags
            if (isAdmin()) {
                const deleteBtn = document.createElement('span');
                deleteBtn.textContent = ' √ó';
                deleteBtn.style.cursor = 'pointer';
                deleteBtn.style.fontWeight = 'bold';
                deleteBtn.style.marginLeft = '4px';
                deleteBtn.onclick = (e) => {
                    e.stopPropagation();
                    removeTag(imageId, tag);
                };
                tagEl.appendChild(deleteBtn);
            }
        });
    } else {
        tagsContainer.innerHTML = '<span style="color: #999; font-size: 12px;">no tags yet</span>';
    }
    
    // Admin can add new tags with autocomplete
    if (isAdmin()) {
        const tagInputWrapper = document.createElement('div');
        tagInputWrapper.style.cssText = 'position: relative; display: inline-block; margin-top: 10px;';
        tagInputWrapper.id = 'tagInputWrapper-' + imageId; // Unique ID

        const addTagInput = document.createElement('input');
        addTagInput.type = 'text';
        addTagInput.placeholder = 'add tag...';
        addTagInput.style.cssText = 'padding: 6px 12px; border: 1px solid #8b7355; font-family: "Courier New", Courier, monospace; font-size: 11px; width: 150px;';
        addTagInput.autocomplete = 'off';

        const autocompleteDropdown = document.createElement('div');
        autocompleteDropdown.style.cssText = 'position: absolute; top: 100%; left: 0; width: 200px; max-height: 200px; overflow-y: auto; background: #fff; border: 1px solid #8b7355; z-index: 10000; display: none; box-shadow: 0 2px 5px rgba(0,0,0,0.2);';

        // Load existing tags and setup autocomplete
        let existingTags = [];

        // Use MASTER_TAG_LIST as fallback + fetch from database
        existingTags = [...MASTER_TAG_LIST];
        getAllExistingTags().then(dbTags => {
            // Merge with database tags (unique)
            const allTags = new Set([...existingTags, ...dbTags]);
            existingTags = Array.from(allTags).sort();
        });

        // Show autocomplete on input
        addTagInput.addEventListener('input', (e) => {
            e.stopPropagation();
            const value = addTagInput.value.trim().toLowerCase();
            autocompleteDropdown.innerHTML = '';

            if (value.length > 0 && existingTags.length > 0) {
                const matches = existingTags.filter(tag =>
                    tag.toLowerCase().includes(value) && tag.toLowerCase() !== value
                );

                if (matches.length > 0) {
                    matches.slice(0, 10).forEach(tag => {
                        const option = document.createElement('div');
                        option.textContent = tag;
                        option.style.cssText = 'padding: 6px 10px; cursor: pointer; font-family: "Courier New", Courier, monospace; font-size: 11px; border-bottom: 1px solid #eee;';
                        option.onmouseover = () => option.style.background = '#f0e0d6';
                        option.onmouseout = () => option.style.background = '#fff';
                        option.onclick = (e) => {
                            e.stopPropagation();
                            addTagInput.value = tag;
                            autocompleteDropdown.style.display = 'none';
                            addTagInput.focus();
                        };
                        autocompleteDropdown.appendChild(option);
                    });
                    autocompleteDropdown.style.display = 'block';
                } else {
                    autocompleteDropdown.style.display = 'none';
                }
            } else {
                autocompleteDropdown.style.display = 'none';
            }
        });

        // Show dropdown on focus if there's text
        addTagInput.addEventListener('focus', () => {
            if (addTagInput.value.trim().length > 0) {
                addTagInput.dispatchEvent(new Event('input'));
            }
        });

        // Hide dropdown when clicking outside - use a specific handler
        const outsideClickHandler = (e) => {
            if (tagInputWrapper && !tagInputWrapper.contains(e.target)) {
                autocompleteDropdown.style.display = 'none';
            }
        };
        setTimeout(() => {
            document.addEventListener('click', outsideClickHandler);
        }, 100);

        // Cleanup on modal close
        const cleanupHandler = () => {
            document.removeEventListener('click', outsideClickHandler);
        };

        // Allow Enter key to add tag
        addTagInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                const newTag = addTagInput.value.trim().toLowerCase();
                if (newTag) {
                    addTag(imageId, newTag);
                    addTagInput.value = '';
                    autocompleteDropdown.style.display = 'none';
                }
            }
        });

        const addTagBtn = document.createElement('button');
        addTagBtn.textContent = '+';
        addTagBtn.style.cssText = 'margin-left: 5px; padding: 6px 12px; background: #d4c5b0; border: 1px solid #8b7355; cursor: pointer; font-family: "Courier New", Courier, monospace;';
        addTagBtn.onclick = (e) => {
            e.preventDefault();
            const newTag = addTagInput.value.trim().toLowerCase();
            if (newTag) {
                addTag(imageId, newTag);
                addTagInput.value = '';
                autocompleteDropdown.style.display = 'none';
            }
        };

        tagInputWrapper.appendChild(addTagInput);
        tagInputWrapper.appendChild(autocompleteDropdown);

        tagsContainer.appendChild(document.createElement('br'));
        tagsContainer.appendChild(tagInputWrapper);
        tagsContainer.appendChild(addTagBtn);

        // Store cleanup function for when modal closes
        window.tagAutocompleteCleanup = cleanupHandler;
    }
            
            // Setup shop button
            const shopBtn = document.getElementById('shopButton');
            if (link) {
                shopBtn.style.display = 'block';
                shopBtn.onclick = () => window.open(link, '_blank');
            } else {
                shopBtn.style.display = 'none';
            }
      
            document.getElementById('imageDetailModal').style.display = 'flex';
        };

        window.closeImageDetail = function() {
            document.getElementById('imageDetailModal').style.display = 'none';
        };

// Admin function: Add tag to image
async function addTag(imageId, newTag) {
    try {
        const imageRef = doc(db, 'images', imageId);
        const imageDoc = await getDoc(imageRef);
        const currentTags = imageDoc.data().tags || [];
        
        if (currentTags.includes(newTag)) {
            alert('Tag already exists');
            return;
        }
        
        await updateDoc(imageRef, {
            tags: arrayUnion(newTag)
        });
        
        // Reload the modal with updated tags
        const data = (await getDoc(imageRef)).data();
        openImageDetail(imageId, data.imageUrl, data.link, data.tags);
        
        console.log('Tag added:', newTag);
    } catch (error) {
        alert('Error adding tag: ' + error.message);
    }
}

// Admin function: Remove tag from image
async function removeTag(imageId, tagToRemove) {
    if (!confirm(`Remove tag "${tagToRemove}"?`)) return;
    
    try {
        const imageRef = doc(db, 'images', imageId);
        const imageDoc = await getDoc(imageRef);
        const currentTags = imageDoc.data().tags || [];
        
        const updatedTags = currentTags.filter(tag => tag !== tagToRemove);
        
        await updateDoc(imageRef, {
            tags: updatedTags
        });
        
        // Reload the modal with updated tags
        const data = (await getDoc(imageRef)).data();
        openImageDetail(imageId, data.imageUrl, data.link, data.tags);
        
        console.log('Tag removed:', tagToRemove);
    } catch (error) {
        alert('Error removing tag: ' + error.message);
    }
}

// Load images filtered by tag(s) - supports multi-tag filtering
async function loadTagFeed(tag, addToHistory = true, resetFilters = true) {
    closeSidebar(); // Close sidebar if open

    // Save CURRENT page to history BEFORE navigating
    if (addToHistory && currentContext.type !== 'tag') {
        navigationHistory.push({ ...currentContext });
    }

    // If resetFilters is true, start fresh with just this tag
    if (resetFilters) {
        activeTagFilters = [tag];
    }

    // Update current context
    currentContext = { type: 'tag', id: tag, tags: [...activeTagFilters] };

    // Build title with all active filters
    const titleText = activeTagFilters.map(t => `#${t}`).join(' + ');
    document.getElementById('pageTitle').innerHTML = '';

    // Add back button if there's navigation history
    if (navigationHistory.length > 1) {
        const backBtn = document.createElement('span');
        backBtn.textContent = '‚Üê back ';
        backBtn.style.cursor = 'pointer';
        backBtn.style.color = '#0600ff';
        backBtn.style.marginRight = '5px';
        backBtn.onclick = goBack;
        document.getElementById('pageTitle').appendChild(backBtn);
    }

    const titleSpan = document.createElement('span');
    titleSpan.textContent = `/ ${titleText}`;
    document.getElementById('pageTitle').appendChild(titleSpan);

    // Save current page to localStorage
    localStorage.setItem('currentPage', JSON.stringify({ type: 'tag', tags: activeTagFilters }));

    const grid = document.getElementById('imageGrid');
    grid.innerHTML = '';

    // Remove any existing filter controls
    const existingFilterControls = grid.parentElement.querySelector('.tag-filter-controls');
    if (existingFilterControls) {
        existingFilterControls.remove();
    }

    // Only show filter controls if we're on a tag page (not on everything/collection/profile pages)
    if (currentContext.type === 'tag') {
        // Add filter controls section
        const filterControls = document.createElement('div');
        filterControls.className = 'tag-filter-controls';
        filterControls.style.cssText = 'margin-bottom: 15px; padding: 10px; background: #eee; border: 1px solid #ccc;';

        // Active filters display
        if (activeTagFilters.length > 0) {
            const activeFiltersDiv = document.createElement('div');
            activeFiltersDiv.style.cssText = 'margin-bottom: 10px; font-family: "Courier New", Courier, monospace; font-size: 12px;';

            activeTagFilters.forEach(filterTag => {
                const filterPill = document.createElement('span');
                filterPill.className = 'tag-pill';
                filterPill.style.cssText = 'margin-right: 5px; margin-bottom: 5px; display: inline-block;';
                filterPill.innerHTML = `${filterTag} <span style="cursor: pointer; font-weight: bold; margin-left: 4px;">√ó</span>`;
                filterPill.querySelector('span').onclick = () => removeTagFilter(filterTag);
                activeFiltersDiv.appendChild(filterPill);
            });

            filterControls.appendChild(activeFiltersDiv);
        }

        // Filter buttons
        const buttonContainer = document.createElement('div');
        buttonContainer.style.cssText = 'display: flex; gap: 10px;';

        const quickFiltersBtn = document.createElement('button');
        quickFiltersBtn.textContent = '+ quick filters';
        quickFiltersBtn.style.cssText = 'padding: 8px 12px; background: #d4c5b0; border: 1px solid #8b7355; cursor: pointer; font-family: "Courier New", Courier, monospace; font-size: 11px;';
        quickFiltersBtn.onclick = () => showQuickFilters();

        const allTagsBtn = document.createElement('button');
        allTagsBtn.textContent = '+ all tags';
        allTagsBtn.style.cssText = 'padding: 8px 12px; background: #d4c5b0; border: 1px solid #8b7355; cursor: pointer; font-family: "Courier New", Courier, monospace; font-size: 11px;';
        allTagsBtn.onclick = () => showAllTagsFilter();

        buttonContainer.appendChild(quickFiltersBtn);
        buttonContainer.appendChild(allTagsBtn);
        filterControls.appendChild(buttonContainer);

        grid.parentElement.insertBefore(filterControls, grid);
    }

    try {
        const imagesQuery = query(collection(db, 'images'), orderBy('createdAt', 'desc'));
        const snapshot = await getDocs(imagesQuery);

        snapshot.forEach((doc) => {
            const data = doc.data();
            const imageTags = data.tags || [];

            // Check if image has ALL active filter tags
            const hasAllTags = activeTagFilters.every(filterTag => imageTags.includes(filterTag));

            if (hasAllTags) {
                const item = document.createElement('div');
                item.className = 'image-item';
                item.dataset.imageId = doc.id;
                item.dataset.userId = data.userId;
                item.dataset.imageUrl = data.imageUrl;
                item.dataset.link = data.link || '';
                item.dataset.tags = JSON.stringify(imageTags);
                item.innerHTML = `<img src="${data.imageUrl}" alt="" draggable="false">`;

                addGestureHandlers(item);

                grid.appendChild(item);
            }
        });

        // Show message if no images found
        if (grid.children.length === 0) {
            grid.innerHTML = '<div style="padding: 20px; text-align: center; color: #666;">No images with these tags yet</div>';
        }
    } catch (error) {
        console.error('Error loading tag feed:', error);
    }
}

// Make it globally accessible
window.loadTagFeed = loadTagFeed;

// Navigation: Go back to previous page
function goBack() {
    if (navigationHistory.length > 0) {
        // Pop the previous page from history
        const previousPage = navigationHistory.pop();

        // Navigate WITHOUT adding to history (addToHistory = false)
        if (previousPage.type === 'tag') {
            activeTagFilters = previousPage.tags || [previousPage.id];
            loadTagFeed(activeTagFilters[0], false, false);
        } else if (previousPage.type === 'everything') {
            loadEverythingFeed(false);
        } else if (previousPage.type === 'profile') {
            loadMyProfile(false);
        } else if (previousPage.type === 'collection') {
            loadCollection(previousPage.id, previousPage.name, false);
        } else if (previousPage.type === 'userProfile') {
            loadUserProfile(previousPage.id, previousPage.username, false);
        }
    } else {
        // No history - go to everything feed
        loadEverythingFeed(false);
    }
}

// Remove a tag from active filters
function removeTagFilter(tagToRemove) {
    activeTagFilters = activeTagFilters.filter(t => t !== tagToRemove);

    if (activeTagFilters.length === 0) {
        // If no filters left, go back to everything feed
        goBack();
    } else {
        // Reload with remaining filters
        loadTagFeed(activeTagFilters[0], false, false);
    }
}

// Add a tag to active filters
function addTagFilter(tagToAdd) {
    if (!activeTagFilters.includes(tagToAdd)) {
        activeTagFilters.push(tagToAdd);
        loadTagFeed(activeTagFilters[0], false, false);
    }
}

// Show quick filters - top 10 co-occurring tags
async function showQuickFilters() {
    try {
        const imagesQuery = query(collection(db, 'images'), orderBy('createdAt', 'desc'));
        const snapshot = await getDocs(imagesQuery);

        // Get all images that have ALL current active filters
        const matchingImages = [];
        snapshot.forEach((doc) => {
            const data = doc.data();
            const imageTags = data.tags || [];
            const hasAllTags = activeTagFilters.every(filterTag => imageTags.includes(filterTag));
            if (hasAllTags) {
                matchingImages.push(imageTags);
            }
        });

        // Count co-occurring tags (exclude already active filters)
        const tagCounts = {};
        matchingImages.forEach(imageTags => {
            imageTags.forEach(tag => {
                if (!activeTagFilters.includes(tag)) {
                    // Apply item exclusivity rule
                    const hasItemInFilters = activeTagFilters.some(filterTag => isItemTag(filterTag));
                    if (hasItemInFilters && isItemTag(tag)) {
                        // Skip this tag - don't show other items if we already have an item
                        return;
                    }
                    tagCounts[tag] = (tagCounts[tag] || 0) + 1;
                }
            });
        });

        // Sort by count and get top 10
        const topTags = Object.entries(tagCounts)
            .sort((a, b) => b[1] - a[1])
            .slice(0, 10);

        if (topTags.length === 0) {
            alert('No additional tags found for these images');
            return;
        }

        // Show modal with quick filters
        showQuickFiltersModal(topTags);

    } catch (error) {
        console.error('Error loading quick filters:', error);
    }
}

// Show modal with quick filter options
function showQuickFiltersModal(topTags) {
    const modal = document.createElement('div');
    modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 3000; display: flex; justify-content: center; align-items: center;';

    const content = document.createElement('div');
    content.style.cssText = 'background: #f0e0d6; padding: 20px; border: 2px solid #8b7355; max-width: 400px; width: 90%; max-height: 70vh; overflow-y: auto; font-family: "Courier New", Courier, monospace;';

    const title = document.createElement('h3');
    title.textContent = 'quick filters';
    title.style.cssText = 'margin-bottom: 15px; font-size: 14px;';
    content.appendChild(title);

    const tagList = document.createElement('div');
    topTags.forEach(([tag, count]) => {
        const tagBtn = document.createElement('button');
        tagBtn.textContent = `${tag} (${count})`;
        tagBtn.style.cssText = 'display: block; width: 100%; padding: 8px 12px; margin-bottom: 5px; background: #d4c5b0; border: 1px solid #8b7355; cursor: pointer; font-family: "Courier New", Courier, monospace; font-size: 12px; text-align: left;';
        tagBtn.onclick = () => {
            addTagFilter(tag);
            document.body.removeChild(modal);
        };
        tagList.appendChild(tagBtn);
    });
    content.appendChild(tagList);

    const closeBtn = document.createElement('button');
    closeBtn.textContent = 'close';
    closeBtn.style.cssText = 'width: 100%; padding: 10px; margin-top: 10px; background: #9ed2f5; border: 1px solid #7ab8db; cursor: pointer; font-family: "Courier New", Courier, monospace;';
    closeBtn.onclick = () => document.body.removeChild(modal);
    content.appendChild(closeBtn);

    modal.appendChild(content);
    modal.onclick = (e) => {
        if (e.target === modal) document.body.removeChild(modal);
    };

    document.body.appendChild(modal);
}

// Show all tags filter with categories
async function showAllTagsFilter() {
    try {
        const imagesQuery = query(collection(db, 'images'), orderBy('createdAt', 'desc'));
        const snapshot = await getDocs(imagesQuery);

        // Get all images that have ALL current active filters
        const matchingImages = [];
        snapshot.forEach((doc) => {
            const data = doc.data();
            const imageTags = data.tags || [];
            const hasAllTags = activeTagFilters.every(filterTag => imageTags.includes(filterTag));
            if (hasAllTags) {
                matchingImages.push(imageTags);
            }
        });

        // Count all tags
        const tagCounts = {};
        matchingImages.forEach(imageTags => {
            imageTags.forEach(tag => {
                if (!activeTagFilters.includes(tag)) {
                    tagCounts[tag] = (tagCounts[tag] || 0) + 1;
                }
            });
        });

        // Organize by category with item exclusivity logic
        const hasItemInFilters = activeTagFilters.some(filterTag => isItemTag(filterTag));
        const categorizedTags = {};

        Object.entries(TAG_CATEGORIES).forEach(([category, tags]) => {
            // Skip Items category if we already have an item in filters
            if (category === 'Items' && hasItemInFilters) {
                return;
            }

            categorizedTags[category] = tags.map(tag => ({
                tag,
                count: tagCounts[tag] || 0
            })).filter(item => {
                // Only show tags that exist in the data or are already active
                return item.count > 0 || activeTagFilters.includes(item.tag);
            });
        });

        showAllTagsModal(categorizedTags);

    } catch (error) {
        console.error('Error loading all tags filter:', error);
    }
}

// Show modal with all tags organized by category
function showAllTagsModal(categorizedTags) {
    const modal = document.createElement('div');
    modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 3000; display: flex; justify-content: center; align-items: center;';

    const content = document.createElement('div');
    content.style.cssText = 'background: #f0e0d6; padding: 20px; border: 2px solid #8b7355; max-width: 500px; width: 90%; max-height: 80vh; overflow-y: auto; font-family: "Courier New", Courier, monospace;';

    const title = document.createElement('h3');
    title.textContent = 'all tags';
    title.style.cssText = 'margin-bottom: 15px; font-size: 14px;';
    content.appendChild(title);

    // Display each category
    Object.entries(categorizedTags).forEach(([category, tags]) => {
        if (tags.length === 0) return;

        const categoryTitle = document.createElement('h4');
        categoryTitle.textContent = category;
        categoryTitle.style.cssText = 'margin-top: 15px; margin-bottom: 8px; font-size: 12px; color: #666; text-transform: uppercase;';
        content.appendChild(categoryTitle);

        const tagGrid = document.createElement('div');
        tagGrid.style.cssText = 'display: flex; flex-wrap: wrap; gap: 5px; margin-bottom: 10px;';

        tags.forEach(({ tag, count }) => {
            const tagBtn = document.createElement('button');
            tagBtn.textContent = `${tag} (${count})`;

            const isDisabled = count === 0;
            const btnStyle = isDisabled
                ? 'padding: 6px 10px; background: #ccc; color: #999; border: 1px solid #aaa; cursor: not-allowed; font-family: "Courier New", Courier, monospace; font-size: 11px;'
                : 'padding: 6px 10px; background: #d4c5b0; color: #000; border: 1px solid #8b7355; cursor: pointer; font-family: "Courier New", Courier, monospace; font-size: 11px;';

            tagBtn.style.cssText = btnStyle;
            tagBtn.disabled = isDisabled;

            if (!isDisabled) {
                tagBtn.onclick = () => {
                    addTagFilter(tag);
                    document.body.removeChild(modal);
                };
            }

            tagGrid.appendChild(tagBtn);
        });

        content.appendChild(tagGrid);
    });

    const closeBtn = document.createElement('button');
    closeBtn.textContent = 'close';
    closeBtn.style.cssText = 'width: 100%; padding: 10px; margin-top: 15px; background: #9ed2f5; border: 1px solid #7ab8db; cursor: pointer; font-family: "Courier New", Courier, monospace;';
    closeBtn.onclick = () => document.body.removeChild(modal);
    content.appendChild(closeBtn);

    modal.appendChild(content);
    modal.onclick = (e) => {
        if (e.target === modal) document.body.removeChild(modal);
    };

    document.body.appendChild(modal);
}
        
        // Open chat unlock modal
        window.openChatUnlock = function() {
            document.getElementById('chatUnlockModal').style.display = 'flex';
        };

        window.closeChatUnlock = function() {
            document.getElementById('chatUnlockModal').style.display = 'none';
            document.getElementById('brandInput').value = '';
        };

        // Submit chat unlock (inline version)
        window.submitChatUnlockInline = async function() {
            const brand = document.getElementById('brandInputInline').value.trim();
            if (!brand) {
                alert('Please enter a brand name');
                return;
            }

            try {
                await addDoc(collection(db, 'chat'), {
                    userId: auth.currentUser.uid,
                    username: (await getDoc(doc(db, 'users', auth.currentUser.uid))).data().username,
                    message: `My favorite lowkey brand: ${brand}`,
                    timestamp: new Date()
                });

                await updateDoc(doc(db, 'users', auth.currentUser.uid), {
                    chatUnlocked: true
                });

                document.getElementById('chatTab').classList.add('unlocked');
                document.getElementById('secretSecretOverlay').classList.remove('active');
                document.getElementById('brandInputInline').value = '';
                
                loadChatMessages();
                toggleChatbox();
                
                alert('Chat unlocked! Welcome to the secret chat.');
            } catch (error) {
                alert('Error unlocking chat: ' + error.message);
            }
        };

        // Submit chat unlock
        window.submitChatUnlock = async function() {
            const brand = document.getElementById('brandInput').value.trim();
            if (!brand) {
                alert('Please enter a brand name');
                return;
            }

            try {
                await addDoc(collection(db, 'chat'), {
                    userId: auth.currentUser.uid,
                    username: (await getDoc(doc(db, 'users', auth.currentUser.uid))).data().username,
                    message: `My favorite lowkey brand: ${brand}`,
                    timestamp: new Date()
                });

                await updateDoc(doc(db, 'users', auth.currentUser.uid), {
                    chatUnlocked: true
                });

                document.getElementById('chatTab').classList.add('unlocked');
                document.getElementById('chatUnlockModal').style.display = 'none';
                document.getElementById('secretSecretOverlay').classList.remove('active');
                document.getElementById('brandInput').value = '';
                
                loadChatMessages();
                toggleChatbox();
                
                alert('Chat unlocked! Welcome to the secret chat.');
            } catch (error) {
                alert('Error unlocking chat: ' + error.message);
            }
        };

        // Toggle chatbox open/close
        window.toggleChatbox = function() {
            document.getElementById('chatbox').classList.toggle('open');
        };

        // Load chat messages with realtime updates
        let chatUnsubscribe = null;
        
        async function loadChatMessages() {
            const messagesDiv = document.getElementById('chatMessages');
            
            try {
                if (chatUnsubscribe) {
                    chatUnsubscribe();
                }
                
                const chatQuery = query(collection(db, 'chat'), orderBy('timestamp', 'asc'));
                
                chatUnsubscribe = onSnapshot(chatQuery, (snapshot) => {
                    messagesDiv.innerHTML = '';
                    
                    // Process messages and get colors
                    snapshot.forEach(async (docSnap) => {
                        const data = docSnap.data();
                        const messageDiv = document.createElement('div');
                        messageDiv.className = 'chat-message';
                        
                        // Determine username color
                        let usernameColor = '#0600ff'; // default blue
                        let colorStyle = '';
                        
                        if (data.userId === auth.currentUser.uid) {
                            // Your own messages always stay red
                            colorStyle = 'color: #ff0000;';
                        } else {
                            // Others get ranking colors based on upload count
                            let uploadCount = 0;
                            
                            try {
                                // Count user's uploads
                                const imagesQuery = query(collection(db, 'images'));
                                const imagesSnapshot = await getDocs(imagesQuery);
                                imagesSnapshot.forEach((imgDoc) => {
                                    if (imgDoc.data().userId === data.userId) {
                                        uploadCount++;
                                    }
                                });
                                
                                // Determine color based on upload count
                                if (uploadCount >= 100) {
                                    usernameColor = 'linear-gradient(90deg, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #8b00ff)';
                                    colorStyle = `background: ${usernameColor}; -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;`;
                                } else if (uploadCount >= 50) {
                                    colorStyle = 'color: #ffa500;'; // orange
                                } else if (uploadCount >= 25) {
                                    colorStyle = 'color: #ff0074;'; // pink
                                } else if (uploadCount >= 10) {
                                    colorStyle = 'color: #00a86b;'; // green
                                } else {
                                    colorStyle = 'color: #0600ff;'; // blue
                                }
                            } catch (error) {
                                console.error('Error getting user color:', error);
                                colorStyle = 'color: #0600ff;'; // default blue on error
                            }
                        }
                        
                        if (data.userId === auth.currentUser.uid) {
                            messageDiv.classList.add('own');
                            messageDiv.innerHTML = `${data.message} :<span class="username clickable-username" style="${colorStyle}" onclick="loadUserProfile('${data.userId}', '${data.username}')">${data.username}</span>`;
                        } else {
                            messageDiv.innerHTML = `<span class="username clickable-username" style="${colorStyle}" onclick="loadUserProfile('${data.userId}', '${data.username}')">[${data.username}]</span>: ${data.message}`;
                        }
                        
                        messagesDiv.appendChild(messageDiv);
                    });
                    
                    // Scroll to bottom after a brief delay
                    setTimeout(() => {
                        messagesDiv.scrollTop = messagesDiv.scrollHeight;
                    }, 100);
                });
            } catch (error) {
                console.error('Error loading messages:', error);
            }
        }

        // Send message
        window.sendMessage = async function() {
            const input = document.getElementById('chatInput');
            const message = input.value.trim();
            
            if (!message) return;
            
            try {
                const userDoc = await getDoc(doc(db, 'users', auth.currentUser.uid));
                await addDoc(collection(db, 'chat'), {
                    userId: auth.currentUser.uid,
                    username: userDoc.data().username,
                    message: message,
                    timestamp: new Date()
                });
                
                input.value = '';
            } catch (error) {
                alert('Error sending message: ' + error.message);
            }
        };

        // Load collections from database
        let isLoadingCollections = false;
        
        async function loadCollections() {
            if (isLoadingCollections) return;
            isLoadingCollections = true;
            
            const collectionsList = document.getElementById('collectionsList');
            collectionsList.innerHTML = '';
            
         try {
    const collectionsSnapshot = await getDocs(collection(db, 'collections'));
    collectionsSnapshot.forEach((doc) => {
        const data = doc.data();
        
        const container = document.createElement('div');
        container.style.display = 'flex';
        container.style.justifyContent = 'space-between';
        container.style.alignItems = 'center';
        
        const link = document.createElement('a');
        link.href = '#';
        link.textContent = `/ ${data.name}`;
        link.onclick = () => {
            loadCollection(doc.id, data.name);
            return false;
        };
        
        container.appendChild(link);
        
        // Admin can delete collections
        if (isAdmin()) {
            const deleteBtn = document.createElement('span');
            deleteBtn.textContent = '√ó';
            deleteBtn.style.cssText = 'cursor: pointer; color: #999; font-size: 18px; padding: 0 5px;';
            deleteBtn.onclick = (e) => {
                e.stopPropagation();
                deleteCollection(doc.id, data.name);
            };
            container.appendChild(deleteBtn);
        }
        
        collectionsList.appendChild(container);
    });
            } catch (error) {
                console.error('Error loading collections:', error);
            } finally {
                isLoadingCollections = false;
            }
        }

        // Create new collection
        window.createNewCollection = async function() {
            const name = prompt('Collection name:');
            if (!name) return;
            
            try {
                await addDoc(collection(db, 'collections'), {
                    name: name,
                    createdBy: auth.currentUser.uid,
                    createdAt: new Date(),
                    images: []
                });
                loadCollections();
                alert('Collection created!');
            } catch (error) {
                alert('Error creating collection: ' + error.message);
            }
        };

        // Admin function: Delete collection
async function deleteCollection(collectionId, collectionName) {
    if (!confirm(`Delete collection "${collectionName}"? This cannot be undone.`)) return;
    
    try {
        await deleteDoc(doc(db, 'collections', collectionId));
        loadCollections(); // Reload the sidebar
        
        // If currently viewing this collection, go back to everything
        if (currentContext.type === 'collection' && currentContext.id === collectionId) {
            loadEverythingFeed();
        }
        
        alert('Collection deleted!');
    } catch (error) {
        alert('Error deleting collection: ' + error.message);
    }
}

        // Load specific collection
        async function loadCollection(collectionId, collectionName, addToHistory = true) {
            closeSidebar();

            // Save CURRENT page to history BEFORE navigating
            if (addToHistory && !(currentContext.type === 'collection' && currentContext.id === collectionId)) {
                navigationHistory.push({ ...currentContext });
            }

            // Reset active tag filters and remove filter UI
            activeTagFilters = [];
            const existingFilterControls = document.querySelector('.tag-filter-controls');
            if (existingFilterControls) {
                existingFilterControls.remove();
            }

            // Update current context
            currentContext = { type: 'collection', id: collectionId, name: collectionName };
            document.getElementById('pageTitle').innerHTML = `/ ${collectionName}`;

            // Save current page to localStorage
            localStorage.setItem('currentPage', JSON.stringify({
                type: 'collection',
                id: collectionId,
                name: collectionName
            }));
            
            const grid = document.getElementById('imageGrid');
            grid.innerHTML = '';
            
            try {
                const collectionDoc = await getDoc(doc(db, 'collections', collectionId));
                const imageIds = collectionDoc.data().images || [];
                
                for (const imageId of imageIds) {
                    const imageDoc = await getDoc(doc(db, 'images', imageId));
                    if (imageDoc.exists()) {
                        const data = imageDoc.data();
                        const item = document.createElement('div');
                        item.className = 'image-item';
                        item.dataset.imageId = imageDoc.id;
                        item.dataset.userId = data.userId;
                        item.dataset.imageUrl = data.imageUrl;
                        item.dataset.link = data.link || '';
                        item.dataset.tags = JSON.stringify(data.tags || []);
                        item.innerHTML = `<img src="${data.imageUrl}" alt="" draggable="false">`;
                        addGestureHandlers(item, true);
                        grid.appendChild(item);
                    }
                }
            } catch (error) {
                console.error('Error loading collection:', error);
            }
        }

        // Logout function
        window.handleLogout = async function() {
            try {
                await signOut(auth);
            } catch (error) {
                alert(error.message);
            }
        };

        // Auth form submission
        document.getElementById('authForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            const email = document.getElementById('emailInput').value;
            const password = document.getElementById('passwordInput').value;
            const username = document.getElementById('usernameInput').value;

            try {
                if (isSignupMode) {
                    const userCredential = await createUserWithEmailAndPassword(auth, email, password);
                    await setDoc(doc(db, 'users', userCredential.user.uid), {
                        username: username,
                        email: email,
                        createdAt: new Date()
                    });
                } else {
                    await signInWithEmailAndPassword(auth, email, password);
                }
            } catch (error) {
                alert(error.message);
            }
        });

        // Toggle between login and signup
        window.toggleAuthMode = function() {
            isSignupMode = !isSignupMode;
            const submit = document.getElementById('authSubmit');
            const switchText = document.getElementById('authSwitch');
            const usernameInput = document.getElementById('usernameInput');

            if (isSignupMode) {
                submit.textContent = 'create account';
                switchText.innerHTML = 'have an account? <a href="#" onclick="toggleAuthMode(); return false;">login</a>';
                usernameInput.style.display = 'block';
                usernameInput.required = true;
            } else {
                submit.textContent = 'login';
                switchText.innerHTML = 'need an account? <a href="#" onclick="toggleAuthMode(); return false;">sign up</a>';
                usernameInput.style.display = 'none';
                usernameInput.required = false;
            }
        };

        // Design Packages System
        const packageData = {
            'tobacco-royale': {
                colors: ['#8b4513', '#d2691e', '#a0522d', '#654321', '#f4a460', '#deb887', '#d2b48c', '#ffe4c4'],
                pattern: '.‚ãÖÀö‚Çä‚Äß üú≤ ‚Äß‚ÇäÀö ‚ãÖ'
            },
            'princess-peach': {
                colors: ['#f21d92', '#72779f', '#82bd67', '#975683', '#f7ffaf', '#ff8bb4', '#b9a6e1', '#ffd1ff'],
                pattern: '.‚ãÖÀö‚Çä‚Äß üú≤ ‚Äß‚ÇäÀö ‚ãÖ'
            },
            'space-cow': {
                colors: ['#000033', '#191970', '#483d8b', '#6a5acd', '#b0c4de', '#e0ffff', '#f0f8ff', '#ffffff'],
                pattern: '.‚ãÖÀö‚Çä‚Äß üú≤ ‚Äß‚ÇäÀö ‚ãÖ'
            },
            'swamp-witch': {
                colors: ['#2f4f2f', '#556b2f', '#6b8e23', '#808000', '#9acd32', '#adff2f', '#7fff00', '#98fb98'],
                pattern: '.‚ãÖÀö‚Çä‚Äß üú≤ ‚Äß‚ÇäÀö ‚ãÖ'
            }
        };

        const unlockMilestones = [10, 25, 50, 100];

        let currentPackage = null;
        let editMode = 'background';
        let selectedBgColor = '#f0e0d6';
        let selectedPatternColor = '#ffffff';

        window.openDesignPackages = async function() {
            document.getElementById('designPackagesOverlay').style.display = 'block';
            
            // Get user's upload count
            const imagesQuery = query(collection(db, 'images'));
            const snapshot = await getDocs(imagesQuery);
            let uploadCount = 0;
            snapshot.forEach((doc) => {
                if (doc.data().userId === auth.currentUser.uid) {
                    uploadCount++;
                }
            });
            
            // Get user's unlocked packages from Firebase
            const userDoc = await getDoc(doc(db, 'users', auth.currentUser.uid));
            const unlockedPackages = userDoc.exists() && userDoc.data().unlockedPackages ? userDoc.data().unlockedPackages : [];
            
            // Determine how many packages they can unlock based on upload count
            let availableUnlocks = 0;
            if (uploadCount >= 100) availableUnlocks = 4;
            else if (uploadCount >= 50) availableUnlocks = 3;
            else if (uploadCount >= 25) availableUnlocks = 2;
            else if (uploadCount >= 10) availableUnlocks = 1;
            
            // Determine next unlock milestone
            const currentUnlocked = unlockedPackages.length;
            let nextMilestone = null;
            if (currentUnlocked < 4 && currentUnlocked < availableUnlocks) {
                // They have unlocks available but haven't used them all
                nextMilestone = null; // They can unlock now
            } else if (currentUnlocked < 4) {
                // They need more uploads
                nextMilestone = unlockMilestones[currentUnlocked];
            }
            
            // Update corner indicator
            const indicator = document.getElementById('nextUnlockIndicator');
            if (currentUnlocked >= 4) {
                indicator.textContent = 'all unlocked!';
            } else if (nextMilestone) {
                indicator.textContent = `next unlock: ${nextMilestone} uploads`;
            } else {
                indicator.textContent = `unlock available!`;
            }
            
            // Update lock status for each package
            Object.keys(packageData).forEach(packageKey => {
                const lockEl = document.getElementById(`lock-${packageKey.split('-')[0]}`);
                
                if (unlockedPackages.includes(packageKey)) {
                    // Already unlocked
                    lockEl.textContent = '‚úì';
                    lockEl.style.color = '#00a86b';
                } else if (currentUnlocked < availableUnlocks) {
                    // Can unlock this one
                    lockEl.textContent = 'üîí';
                    lockEl.style.color = '#000';
                } else {
                    // Still locked
                    lockEl.textContent = 'üîí';
                    lockEl.style.color = '#999';
                }
            });
        };

        window.closeDesignPackages = function() {
            document.getElementById('designPackagesOverlay').style.display = 'none';
        };

        window.selectPackage = async function(packageKey) {
            // Get user's data
            const imagesQuery = query(collection(db, 'images'));
            const snapshot = await getDocs(imagesQuery);
            let uploadCount = 0;
            snapshot.forEach((doc) => {
                if (doc.data().userId === auth.currentUser.uid) {
                    uploadCount++;
                }
            });
            
            const userDoc = await getDoc(doc(db, 'users', auth.currentUser.uid));
            const unlockedPackages = userDoc.exists() && userDoc.data().unlockedPackages ? userDoc.data().unlockedPackages : [];
            
            // Check if already unlocked
            if (unlockedPackages.includes(packageKey)) {
                // Open customization
                openPackageCustomization(packageKey);
                return;
            }
            
            // Check if they can unlock
            let availableUnlocks = 0;
            if (uploadCount >= 100) availableUnlocks = 4;
            else if (uploadCount >= 50) availableUnlocks = 3;
            else if (uploadCount >= 25) availableUnlocks = 2;
            else if (uploadCount >= 10) availableUnlocks = 1;
            
            const currentUnlocked = unlockedPackages.length;
            
            if (currentUnlocked >= availableUnlocks) {
                // Need more uploads
                const nextMilestone = unlockMilestones[currentUnlocked];
                alert(`You need ${nextMilestone} uploads to unlock another package. You currently have ${uploadCount} uploads.`);
                return;
            }
            
            // Can unlock! Ask for confirmation
            if (confirm(`Unlock ${packageKey.replace('-', ' ')}? This will use 1 of your available unlock slots.`)) {
                // Add to unlocked packages
                const updatedUnlocked = [...unlockedPackages, packageKey];
                await setDoc(doc(db, 'users', auth.currentUser.uid), {
                    unlockedPackages: updatedUnlocked
                }, { merge: true });
                
                // Open customization
                openPackageCustomization(packageKey);
            }
        };

        async function openPackageCustomization(packageKey) {
            currentPackage = packageKey;
            document.getElementById('packageTitle').textContent = packageKey.replace('-', ' ');
            
            // Populate color grid
            const colorGrid = document.getElementById('colorGrid');
            colorGrid.innerHTML = '';
            packageData[packageKey].colors.forEach(color => {
                const btn = document.createElement('button');
                btn.style.cssText = `background: ${color}; aspect-ratio: 1; border: none; cursor: pointer;`;
                btn.onclick = () => applyPackageColor(color);
                colorGrid.appendChild(btn);
            });
            
            document.getElementById('designPackagesOverlay').style.display = 'none';
            document.getElementById('packageCustomizationOverlay').style.display = 'block';
        }

        window.closePackageCustomization = function() {
            document.getElementById('packageCustomizationOverlay').style.display = 'none';
        };

        window.setEditModePackage = function(mode) {
            editMode = mode;
            const bgBtn = document.getElementById('bgToggleBtn');
            const patternBtn = document.getElementById('patternToggleBtn');
            
            if (mode === 'background') {
                bgBtn.style.background = '#000';
                bgBtn.style.color = '#fff';
                patternBtn.style.background = '#fff';
                patternBtn.style.color = '#000';
            } else {
                patternBtn.style.background = '#000';
                patternBtn.style.color = '#fff';
                bgBtn.style.background = '#fff';
                bgBtn.style.color = '#000';
            }
        };

        window.applyPackageColor = function(color) {
            if (editMode === 'background') {
                selectedBgColor = color;
                document.getElementById('currentBgDisplay').textContent = color;
            } else {
                selectedPatternColor = color;
                document.getElementById('currentPatternDisplay').textContent = color;
            }
        };

        window.applyTheme = async function() {
            // Save theme to Firebase
            try {
                await setDoc(doc(db, 'users', auth.currentUser.uid), {
                    theme: {
                        backgroundColor: selectedBgColor,
                        patternColor: selectedPatternColor,
                        patternType: packageData[currentPackage].pattern,
                        package: currentPackage
                    }
                }, { merge: true });
                
                // Apply theme immediately
                document.getElementById('container').style.backgroundColor = selectedBgColor;
                // TODO: Apply pattern overlay
                
                closePackageCustomization();
                alert('Theme applied!');
            } catch (error) {
                console.error('Error saving theme:', error);
                alert('Error saving theme');
            }
        };

        // Load user profile (for viewing other users)
        window.loadUserProfile = async function(userId, username, addToHistory = true) {
            closeSidebar(); // Close sidebar if open
            if (document.getElementById('chatbox').classList.contains('open')) {
                toggleChatbox(); // Close chatbox if open
            }

            // Save CURRENT page to history BEFORE navigating
            if (addToHistory && !(currentContext.type === 'userProfile' && currentContext.id === userId)) {
                navigationHistory.push({ ...currentContext });
            }

            // Reset active tag filters and remove filter UI
            activeTagFilters = [];
            const existingFilterControls = document.querySelector('.tag-filter-controls');
            if (existingFilterControls) {
                existingFilterControls.remove();
            }

            // Update current context
            currentContext = { type: 'userProfile', id: userId, username: username };
            document.getElementById('pageTitle').innerHTML = `/ ${username}'s profile`;

            // Save current page to localStorage
            localStorage.setItem('currentPage', JSON.stringify({ type: 'userProfile', id: userId, username: username }));
            
            const grid = document.getElementById('imageGrid');
            grid.innerHTML = '';
            
            try {
                const imagesQuery = query(
                    collection(db, 'images'), 
                    orderBy('createdAt', 'desc')
                );
                const snapshot = await getDocs(imagesQuery);
                
                snapshot.forEach((doc) => {
                    const data = doc.data();
                    // Only show this user's images
                    if (data.userId === userId) {
                        const item = document.createElement('div');
                        item.className = 'image-item';
                        item.dataset.imageId = doc.id;
                        item.dataset.userId = data.userId;
                        item.dataset.imageUrl = data.imageUrl;
                        item.dataset.link = data.link || '';
                        item.dataset.tags = JSON.stringify(data.tags || []);
                        item.innerHTML = `<img src="${data.imageUrl}" alt="" draggable="false">`;
                        
                        // Add gestures but NO drag (read-only for other users)
                        addGestureHandlers(item, false);
                        
                        grid.appendChild(item);
                    }
                });
            } catch (error) {
                console.error('Error loading user profile:', error);
            }
        };

        // Load account settings page
        window.loadAccountSettings = async function() {
            closeSidebar();
            
            // Reset active tag filters and remove filter UI
            activeTagFilters = [];
            const existingFilterControls = document.querySelector('.tag-filter-controls');
            if (existingFilterControls) {
                existingFilterControls.remove();
            }
            
            // Update context
            currentContext = { type: 'accountSettings' };
            document.getElementById('pageTitle').innerHTML = '/ account settings';
            
            const grid = document.getElementById('imageGrid');
            grid.innerHTML = '';
            
          // Create settings form
            const settingsContainer = document.createElement('div');
           settingsContainer.style.cssText = 'width: 100vw; margin-left: calc(-50vw + 50% + 50px); padding: 15px; box-sizing: border-box; font-family: "Courier New", Courier, monospace;';
            
            settingsContainer.innerHTML = `
                <div style="background: #fff; padding: 20px; border: 2px solid #0600ff; margin-bottom: 20px;">
                    <h3 style="font-size: 16px; margin-bottom: 20px; color: #0600ff;">curator settings</h3>
                    
                    <p style="font-size: 13px; margin-bottom: 15px; line-height: 1.6; color: #666;">
                        Want to earn commissions on eBay finds? Paste your eBay Partner Network Campaign ID below. 
                        When you upload eBay items, we'll automatically add your tracking code so you earn money when people buy!
                    </p>
                    
                    <p style="font-size: 12px; margin-bottom: 20px; color: #999;">
                        Don't have an account yet? <a href="https://partnernetwork.ebay.com" target="_blank" style="color: #0600ff;">Sign up for eBay Partner Network</a>
                    </p>
                    
                    <label style="display: block; margin-bottom: 8px; font-size: 13px; font-weight: bold;">
                        eBay Campaign ID:
                    </label>
                    
                    <input 
                        type="text" 
                        id="campaignIdInput" 
                        placeholder="Example: 5338152157" 
                        style="width: 100%; padding: 12px; border: 2px solid #0600ff; font-family: 'Courier New', Courier, monospace; font-size: 14px; margin-bottom: 15px; box-sizing: border-box;"
                    >
                    
                    <button 
                        onclick="saveCampaignId()" 
                        style="width: 100%; padding: 15px; background: #0600ff; color: white; border: 2px solid #0600ff; font-family: 'Courier New', Courier, monospace; cursor: pointer; font-size: 14px; margin-bottom: 10px;"
                    >
                        save campaign id
                    </button>
                    
                    <div id="saveStatus" style="font-size: 12px; color: #00a86b; text-align: center; margin-top: 10px;"></div>
                </div>
                
                <div style="background: #f5f5f5; padding: 20px; border: 1px solid #ccc;">
                    <h4 style="font-size: 14px; margin-bottom: 10px;">How to find your Campaign ID:</h4>
                    <ol style="font-size: 12px; line-height: 1.8; padding-left: 20px;">
                        <li>Go to <a href="https://partnernetwork.ebay.com" target="_blank" style="color: #0600ff;">eBay Partner Network</a></li>
                        <li>Log in to your account</li>
                        <li>Click "Campaigns" in the top menu</li>
                        <li>Copy the 10-digit Campaign ID number</li>
                        <li>Paste it in the field above</li>
                    </ol>
                </div>
            `;
            
            grid.appendChild(settingsContainer);
            
            // Load existing Campaign ID if they have one
            try {
                const userDoc = await getDoc(doc(db, 'users', auth.currentUser.uid));
                const campaignId = userDoc.data()?.ebayAffiliateCode || '';
                if (campaignId) {
                    document.getElementById('campaignIdInput').value = campaignId;
                }
            } catch (error) {
                console.error('Error loading campaign ID:', error);
            }
        };
        // Save Campaign ID to Firebase
window.saveCampaignId = async function() {
    const campaignId = document.getElementById('campaignIdInput').value.trim();
    const statusDiv = document.getElementById('saveStatus');
    
    if (!campaignId) {
        statusDiv.textContent = 'Please enter a Campaign ID';
        statusDiv.style.color = '#ff0000';
        return;
    }
    
    // Validate it's a number (Campaign IDs are typically 10 digits)
    if (!/^\d+$/.test(campaignId)) {
        statusDiv.textContent = 'Campaign ID should be numbers only';
        statusDiv.style.color = '#ff0000';
        return;
    }
    
    try {
        await setDoc(doc(db, 'users', auth.currentUser.uid), {
            ebayAffiliateCode: campaignId
        }, { merge: true });
        
        statusDiv.textContent = '‚úì Campaign ID saved! You\'ll now earn commissions on eBay uploads.';
        statusDiv.style.color = '#00a86b';
    } catch (error) {
        statusDiv.textContent = 'Error saving: ' + error.message;
        statusDiv.style.color = '#ff0000';
    }
};
        window.loadMyProfile = async function(addToHistory = true) {
            closeSidebar();

            // Save CURRENT page to history BEFORE navigating
            if (addToHistory && currentContext.type !== 'profile') {
                navigationHistory.push({ ...currentContext });
            }

            // Reset active tag filters and remove filter UI
            activeTagFilters = [];
            const existingFilterControls = document.querySelector('.tag-filter-controls');
            if (existingFilterControls) {
                existingFilterControls.remove();
            }

            // Update current context
            currentContext = { type: 'profile', id: auth.currentUser.uid };
            document.getElementById('pageTitle').innerHTML = '/ my profile';

            // Save current page to localStorage
            localStorage.setItem('currentPage', JSON.stringify({ type: 'profile' }));
            
            const grid = document.getElementById('imageGrid');
            grid.innerHTML = '';
            
            try {
                // Get user's custom order if it exists
                const userDoc = await getDoc(doc(db, 'users', auth.currentUser.uid));
                const customOrder = userDoc.data()?.profileImageOrder || null;
                
                // Get all user's images
                const imagesQuery = query(
                    collection(db, 'images'), 
                    orderBy('createdAt', 'desc')
                );
                const snapshot = await getDocs(imagesQuery);
                
                // Filter to only user's images
                const userImages = [];
                snapshot.forEach((doc) => {
                    const data = doc.data();
                    if (data.userId === auth.currentUser.uid) {
                        userImages.push({ id: doc.id, data: data });
                    }
                });
                
                // Sort by custom order if it exists
                if (customOrder && customOrder.length > 0) {
                    userImages.sort((a, b) => {
                        const indexA = customOrder.indexOf(a.id);
                        const indexB = customOrder.indexOf(b.id);
                        // If not in custom order, put at end
                        if (indexA === -1) return 1;
                        if (indexB === -1) return -1;
                        return indexA - indexB;
                    });
                }
                
                // Render images
                userImages.forEach(({ id, data }) => {
                    const item = document.createElement('div');
                    item.className = 'image-item';
                    item.dataset.imageId = id;
                    item.dataset.userId = data.userId;
                    item.dataset.imageUrl = data.imageUrl;
                    item.dataset.link = data.link || '';
                    item.innerHTML = `<img src="${data.imageUrl}" alt="" draggable="false">`;
                    
                    addGestureHandlers(item, true);
                    
                    grid.appendChild(item);
                });
            } catch (error) {
                console.error('Error loading profile:', error);
            }
        };

        // Load everything feed
        async function loadEverythingFeed(addToHistory = true) {
            // Save CURRENT page to history BEFORE navigating
            if (addToHistory && currentContext.type !== 'everything') {
                navigationHistory.push({ ...currentContext });
            }

            // Reset active tag filters and remove filter UI
            activeTagFilters = [];
            const existingFilterControls = document.querySelector('.tag-filter-controls');
            if (existingFilterControls) {
                existingFilterControls.remove();
            }

            // Update current context
            currentContext = { type: 'everything', id: null };
            document.getElementById('pageTitle').innerHTML = '/ everything';

            // Save current page to localStorage
            localStorage.setItem('currentPage', JSON.stringify({ type: 'everything' }));

            const grid = document.getElementById('imageGrid');
            grid.innerHTML = '';

            try {
                const imagesQuery = query(collection(db, 'images'), orderBy('createdAt', 'desc'));
                const snapshot = await getDocs(imagesQuery);

                snapshot.forEach((doc) => {
                    const data = doc.data();
                    const item = document.createElement('div');
                    item.className = 'image-item';
                    item.dataset.imageId = doc.id;
                    item.dataset.userId = data.userId;
                    item.dataset.imageUrl = data.imageUrl;
                    item.dataset.link = data.link || '';
                    item.dataset.tags = JSON.stringify(data.tags || []);
                    item.innerHTML = `<img src="${data.imageUrl}" alt="" draggable="false">`;

                    addGestureHandlers(item);

                    grid.appendChild(item);
                });
            } catch (error) {
                console.error('Error loading images:', error);
            }
        }

        // Restore last viewed page
        async function restoreLastPage() {
            try {
                const savedPage = localStorage.getItem('currentPage');
                if (savedPage) {
                    const page = JSON.parse(savedPage);

                    if (page.type === 'profile') {
                        await loadMyProfile();
                    } else if (page.type === 'collection' && page.id && page.name) {
                        await loadCollection(page.id, page.name);
                   } else if (page.type === 'userProfile' && page.id && page.username) {
                        await loadUserProfile(page.id, page.username);
                    } else if (page.type === 'tag') {
                        // Handle both old (single tag) and new (tags array) format
                        if (page.tags && Array.isArray(page.tags)) {
                            activeTagFilters = page.tags;
                            await loadTagFeed(page.tags[0], true, false);
                        } else if (page.tag) {
                            await loadTagFeed(page.tag);
                        }
                    } else {
                        await loadEverythingFeed();
                    }
                    }
            } catch (error) {
                console.error('Error restoring page:', error);
                await loadEverythingFeed();
            }
        }

        // Gesture detection for images - UPDATED WITH SMOOTH DRAG
        function addGestureHandlers(item, allowDrag = false) {
            let firstTap = null;
            let firstTapPosition = null;
            let tapTimer = null;
            let touchStartTime = 0;
            let touchStartPos = null;
            let holdTimer = null;
            let feedbackTimer = null;
            let isDragging = false;
            let dragStartIndex = null;
            let touchStartX = 0;
            let touchStartY = 0;

            item.addEventListener('touchstart', (e) => {
                touchStartTime = Date.now();
                const touch = e.touches[0];
                const rect = item.getBoundingClientRect();
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;
                touchStartPos = { x, y };
                touchStartX = touch.clientX;
                touchStartY = touch.clientY;
                
                // DON'T prevent default here - let scrolling work!
                
                // Start hold timer for drag if allowed
                if (allowDrag) {
                    // Visual feedback at 0.8 seconds
                    feedbackTimer = setTimeout(() => {
                        item.style.transform = 'scale(0.95)';
                        item.style.transition = 'transform 0.1s ease';
                    }, 800);
                    
                    // Start drag at 1 second
                    holdTimer = setTimeout(() => {
                        isDragging = true;
                        item.classList.add('dragging');
                        dragStartIndex = Array.from(item.parentNode.children).indexOf(item);
                        
                        // Haptic feedback
                        if (navigator.vibrate) {
                            navigator.vibrate(50);
                        }
                    }, 1000);
                }
                
                // Detect which area - corners or center
                const centerMargin = 0.3;
                const isCenter = (
                    x > rect.width * centerMargin && 
                    x < rect.width * (1 - centerMargin) &&
                    y > rect.height * centerMargin && 
                    y < rect.height * (1 - centerMargin)
                );
                
                if (isCenter) {
                    return;
                }
                
                // Detect which corner
                const isLeft = x < rect.width / 2;
                const isRight = x > rect.width / 2;
                const isTop = y < rect.height / 2;
                const isBottom = y > rect.height / 2;
                
                let corner = null;
                if (isTop && isLeft) corner = 'top-left';
                else if (isTop && isRight) corner = 'top-right';
                else if (isBottom && isLeft) corner = 'bottom-left';
                else if (isBottom && isRight) corner = 'bottom-right';

                if (!firstTap) {
                    firstTap = corner;
                    firstTapPosition = { x, y };
                    
                    tapTimer = setTimeout(() => {
                        firstTap = null;
                        firstTapPosition = null;
                    }, 1500);
                } else {
                    const distance = Math.sqrt(
                        Math.pow(x - firstTapPosition.x, 2) + 
                        Math.pow(y - firstTapPosition.y, 2)
                    );
                    
                    if (distance > 50) {
                        e.preventDefault(); // Only prevent when doing corner gesture
                        clearTimeout(tapTimer);
                        
                        if (firstTap === 'top-right' && corner === 'bottom-right') {
                            handleDelete(item);
                        } else if (firstTap === 'top-left' && corner === 'bottom-left') {
                            handleAddToCollection(item);
                        }
                    }
                    
                    firstTap = null;
                    firstTapPosition = null;
                }
            });

            item.addEventListener('touchmove', (e) => {
                if (isDragging) {
                    e.preventDefault();
                    const touch = e.touches[0];
                    
                    // Make item follow finger
                    const deltaX = touch.clientX - touchStartX;
                    const deltaY = touch.clientY - touchStartY;
                    item.style.transform = `translate(${deltaX}px, ${deltaY}px) scale(0.95)`;
                    item.style.zIndex = '1000';
                    
                    // Find what item we're hovering over
                    item.style.pointerEvents = 'none';
                    const elementAtPoint = document.elementFromPoint(touch.clientX, touch.clientY);
                    item.style.pointerEvents = 'auto';
                    
                    const targetItem = elementAtPoint?.closest('.image-item');
                    
                    // Remove all drag-over classes first
                    document.querySelectorAll('.image-item').forEach(i => i.classList.remove('drag-over'));
                    
                    if (targetItem && targetItem !== item) {
                        targetItem.classList.add('drag-over');
                        
                        // Reorder in DOM for smooth shifting
                        const grid = item.parentNode;
                        const items = Array.from(grid.children);
                        const currentIndex = items.indexOf(item);
                        const targetIndex = items.indexOf(targetItem);
                        
                        if (currentIndex < targetIndex) {
                            grid.insertBefore(item, targetItem.nextSibling);
                        } else {
                            grid.insertBefore(item, targetItem);
                        }
                    }
                } else {
                    // If moved during hold, cancel the drag
                    const touch = e.touches[0];
                    const deltaX = touch.clientX - touchStartX;
                    const deltaY = touch.clientY - touchStartY;
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    
                    if (distance > 10) {
                        if (holdTimer) clearTimeout(holdTimer);
                        if (feedbackTimer) clearTimeout(feedbackTimer);
                        item.style.transform = '';
                    }
                }
            });

            item.addEventListener('touchend', (e) => {
                if (holdTimer) clearTimeout(holdTimer);
                if (feedbackTimer) clearTimeout(feedbackTimer);
                
                const touchDuration = Date.now() - touchStartTime;
                
                if (isDragging) {
                    // Save the new order
                    const grid = item.parentNode;
                    
                    // Reset styles smoothly
                    item.classList.remove('dragging');
                    item.style.transform = '';
                    item.style.zIndex = '';
                    document.querySelectorAll('.image-item').forEach(i => {
                        i.classList.remove('drag-over');
                    });
                    
                    // Save to Firebase
                    saveOrderToFirebase(grid);
                    
                    isDragging = false;
                    dragStartIndex = null;
                } else {
                    // Reset any visual feedback
                    item.style.transform = '';
                    
                    // Handle single tap on center for link
                    if (touchStartPos && touchDuration < 300 && !firstTap) {
                        const rect = item.getBoundingClientRect();
                        const centerMargin = 0.3;
                        const isCenter = (
                            touchStartPos.x > rect.width * centerMargin && 
                            touchStartPos.x < rect.width * (1 - centerMargin) &&
                            touchStartPos.y > rect.height * centerMargin && 
                            touchStartPos.y < rect.height * (1 - centerMargin)
                        );
                        
                        if (isCenter) {
                    e.preventDefault();
                    // Open detail modal instead of going directly to link
                    const tags = item.dataset.tags ? JSON.parse(item.dataset.tags) : [];
                    openImageDetail(
                        item.dataset.imageId,
                        item.dataset.imageUrl,
                        item.dataset.link,
                        tags
                    );
                }
                    }
                }
                
                touchStartPos = null;
            });

            item.addEventListener('contextmenu', (e) => {
                e.preventDefault();
            });
        }

        // Save order to Firebase
        async function saveOrderToFirebase(grid) {
            try {
                const imageIds = Array.from(grid.children).map(item => item.dataset.imageId);
                
                if (currentContext.type === 'collection') {
                    await updateDoc(doc(db, 'collections', currentContext.id), {
                        images: imageIds
                    });
                    console.log('Collection order saved!');
                } else if (currentContext.type === 'profile') {
                    // Save profile order - you could store this in a user document
                    await updateDoc(doc(db, 'users', auth.currentUser.uid), {
                        profileImageOrder: imageIds
                    });
                    console.log('Profile order saved!');
                }
            } catch (error) {
                console.error('Error saving order:', error);
            }
        }

        // Handle delete
       async function handleDelete(item) {
    const imageId = item.dataset.imageId;
    const userId = item.dataset.userId;
    
    // Allow admin to delete any image, or users to delete their own
    if (userId !== auth.currentUser.uid && !isAdmin()) {
        alert('You can only delete your own images');
        return;
    }

    try {
        await deleteDoc(doc(db, 'images', imageId));
        item.remove();
        
        if (isAdmin()) {
            console.log('Admin deleted image:', imageId);
        }
    } catch (error) {
        alert('Delete failed: ' + error.message);
    }
}

        // Handle add to collection
        let currentImageToAdd = null;
        let allCollections = [];

        async function handleAddToCollection(item) {
            currentImageToAdd = item.dataset.imageId;
            
            try {
                const collectionsSnapshot = await getDocs(collection(db, 'collections'));
                allCollections = [];
                collectionsSnapshot.forEach((doc) => {
                    allCollections.push({ id: doc.id, name: doc.data().name });
                });

                if (allCollections.length === 0) {
                    alert('No collections yet. Create one first!');
                    return;
                }

                displayCollections(allCollections);
                document.getElementById('collectionPickerModal').style.display = 'flex';
            } catch (error) {
                alert('Error: ' + error.message);
            }
        }

        function displayCollections(collections) {
            const list = document.getElementById('collectionPickerList');
            list.innerHTML = '';
            
            collections.forEach(col => {
                const item = document.createElement('div');
                item.className = 'collection-item';
                item.textContent = col.name;
                item.onclick = () => addToSelectedCollection(col.id, col.name);
                list.appendChild(item);
            });
        }

        async function addToSelectedCollection(collectionId, collectionName) {
            try {
                await updateDoc(doc(db, 'collections', collectionId), {
                    images: arrayUnion(currentImageToAdd)
                });
                closeCollectionPicker();
                alert(`Added to ${collectionName}!`);
            } catch (error) {
                alert('Error: ' + error.message);
            }
        }

        window.closeCollectionPicker = function() {
            document.getElementById('collectionPickerModal').style.display = 'none';
            document.getElementById('collectionSearch').value = '';
            currentImageToAdd = null;
        };

        window.filterCollections = function() {
            const searchTerm = document.getElementById('collectionSearch').value.toLowerCase();
            const filtered = allCollections.filter(col => 
                col.name.toLowerCase().includes(searchTerm)
            );
            displayCollections(filtered);
        };

        // Upload modal functions
        window.openUploadModal = function() {
            document.getElementById('uploadModal').style.display = 'flex';
        };

        window.closeUploadModal = function() {
            document.getElementById('uploadModal').style.display = 'none';
            document.getElementById('uploadForm').reset();
            croppedBlob = null;
            document.getElementById('imageInput').value = '';
        };

        // Rules modal functions
        window.openRulesModal = function() {
            document.getElementById('rulesModal').style.display = 'flex';
        };

        window.closeRulesModal = function() {
            document.getElementById('rulesModal').style.display = 'none';
        };

        // Secret secret rules unlock
        let secretClicks = { title: false, body: false };
        let secretTimer = null;

        window.secretWordClicked = function(location) {
            secretClicks[location] = true;
            
            if (secretTimer) clearTimeout(secretTimer);
            secretTimer = setTimeout(() => {
                secretClicks = { title: false, body: false };
            }, 5000);
            
            if (secretClicks.title && secretClicks.body) {
                openSecretSecretRules();
                secretClicks = { title: false, body: false };
            }
        };

        window.openSecretSecretRules = function() {
            document.getElementById('rulesModal').style.display = 'none';
            document.getElementById('secretSecretOverlay').classList.add('active');
        };

        window.closeSecretSecretRules = function() {
            document.getElementById('secretSecretOverlay').classList.remove('active');
        };

        // Crop functionality
        let originalImage = null;
        let croppedBlob = null;
        let cropBox = null;
        let isDragging = false;
        let startX, startY, startLeft, startTop;

        // Handle image input - no crop
document.getElementById('imageInput').addEventListener('change', function(e) {
    const file = e.target.files[0];
    if (!file) return;
    
    // No crop - just use the file
    croppedBlob = file;
});
        function startDrag(e) {
            e.preventDefault();
            isDragging = true;
            
            const touch = e.touches ? e.touches[0] : e;
            const box = document.getElementById('cropBox');
            
            startX = touch.clientX;
            startY = touch.clientY;
            startLeft = box.offsetLeft;
            startTop = box.offsetTop;
            
            document.onmousemove = drag;
            document.ontouchmove = drag;
            document.onmouseup = stopDrag;
            document.ontouchend = stopDrag;
        }

        function drag(e) {
            if (!isDragging) return;
            e.preventDefault();
            
            const touch = e.touches ? e.touches[0] : e;
            const box = document.getElementById('cropBox');
            const img = document.getElementById('cropImage');
            
            const dx = touch.clientX - startX;
            const dy = touch.clientY - startY;
            
            let newLeft = startLeft + dx;
            let newTop = startTop + dy;
            
            // Constrain to image bounds
            newLeft = Math.max(0, Math.min(newLeft, img.offsetWidth - box.offsetWidth));
            newTop = Math.max(0, Math.min(newTop, img.offsetHeight - box.offsetHeight));
            
            box.style.left = newLeft + 'px';
            box.style.top = newTop + 'px';
        }

        function stopDrag() {
            isDragging = false;
            document.onmousemove = null;
            document.ontouchmove = null;
            document.onmouseup = null;
            document.ontouchend = null;
        }

        window.applyCrop = async function() {
            const img = document.getElementById('cropImage');
            const box = document.getElementById('cropBox');
            
            // Create canvas and crop
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // Get actual image dimensions
            const actualImg = new Image();
            actualImg.src = img.src;
            
            await new Promise(resolve => {
                actualImg.onload = resolve;
            });
            
            const scaleX = actualImg.width / img.offsetWidth;
            const scaleY = actualImg.height / img.offsetHeight;
            
            const cropX = box.offsetLeft * scaleX;
            const cropY = box.offsetTop * scaleY;
            const cropWidth = box.offsetWidth * scaleX;
            const cropHeight = box.offsetHeight * scaleY;
            
            canvas.width = cropWidth;
            canvas.height = cropHeight;
            
            ctx.drawImage(
                actualImg,
                cropX, cropY, cropWidth, cropHeight,
                0, 0, cropWidth, cropHeight
            );
            
            // Convert to blob
            canvas.toBlob(function(blob) {
                croppedBlob = blob;
                document.getElementById('cropModal').style.display = 'none';
            }, 'image/jpeg', 0.9);
        };

        window.cancelCrop = function() {
            document.getElementById('cropModal').style.display = 'none';
            document.getElementById('imageInput').value = '';
            croppedBlob = null;
        };

       // Handle image upload WITH AI TAGGING
        document.getElementById('uploadForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            
            const linkInput = document.getElementById('linkInput');
            
            if (!croppedBlob) {
                alert('Please select and crop an image');
                return;
            }
            
            try {
                // Show uploading message
                const submitBtn = e.target.querySelector('button[type="submit"]');
                const originalText = submitBtn.textContent;
                submitBtn.textContent = 'analyzing image...';
                submitBtn.disabled = true;
                
                // Get AI tags BEFORE uploading
                const aiTags = await getAITags(croppedBlob);
                console.log('AI suggested tags:', aiTags);
                
                submitBtn.textContent = 'uploading...';
                
                // Upload image to storage
                const fileName = `${Date.now()}_cropped.jpg`;
                const storageRef = ref(storage, `images/${fileName}`);
                await uploadBytes(storageRef, croppedBlob);
                const imageUrl = await getDownloadURL(storageRef);

                // Check if user has eBay affiliate code and add to URL if eBay link
                const userDoc = await getDoc(doc(db, 'users', auth.currentUser.uid));
                const campaignId = userDoc.data()?.ebayAffiliateCode || null;

                // If they have a campaign ID and the link is an eBay link, add the campaign ID
                let finalLink = linkInput.value || '';
                if (campaignId && (finalLink.includes('ebay.com') || finalLink.includes('ebay.us'))) {
                    try {
                        const url = new URL(finalLink);
                        url.searchParams.set('campid', campaignId);
                        finalLink = url.toString();
                        console.log('Added campaign ID to eBay link:', finalLink);
                    } catch (error) {
                        console.error('Error parsing URL:', error);
                    }
                }
                // Save to database with tags
                await addDoc(collection(db, 'images'), {
                    imageUrl: imageUrl,
                    link: finalLink,
                    userId: auth.currentUser.uid,
                    createdAt: new Date(),
                    tags: aiTags,
                    aiTags: aiTags
                });
                
                // Reset button
                submitBtn.textContent = originalText;
                submitBtn.disabled = false;
                
                closeUploadModal();
                loadEverythingFeed();
                alert('Upload successful!');
            } catch (error) {
                alert('Upload failed: ' + error.message);
                console.error('Upload error:', error);
                
                // Reset button on error
                const submitBtn = e.target.querySelector('button[type="submit"]');
                submitBtn.textContent = 'upload';
                submitBtn.disabled = false;
            }
        });
        
        window.auth = auth;
        window.db = db;
        window.storage = storage;
        window.currentUser = currentUser;
        window.loadEverythingFeed = loadEverythingFeed;
    </script>

    <script>
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            const overlay = document.getElementById('overlay');
            sidebar.classList.toggle('open');
            overlay.classList.toggle('active');
        }

        function closeSidebar() {
            const sidebar = document.getElementById('sidebar');
            const overlay = document.getElementById('overlay');
            sidebar.classList.remove('open');
            overlay.classList.remove('active');
        }

        function loadPage(page) {
            toggleSidebar();
            
            const titleMap = {
                'everything': '/ everything',
                'profile': '/ my profile',
                'collection': '/ vintage denim',
                'collections': '/ boards'
            };
            document.getElementById('pageTitle').textContent = titleMap[page] || '/ ' + page;
            
            if (page === 'everything') {
                window.loadEverythingFeed();
            }
        }
    </script>
    <!-- Image Detail Modal -->
    <div class="modal" id="imageDetailModal">
        <div class="modal-content" style="max-width: 600px;">
            <h2 style="font-size: 18px; margin-bottom: 20px;">item details</h2>
            <img id="detailImage" style="max-width: 100%; max-height: 50vh; object-fit: contain; margin-bottom: 20px;" alt="Item">
            
            <div style="margin-bottom: 20px;">
                <h3 style="font-size: 14px; margin-bottom: 10px; color: #666;">tags:</h3>
                <div id="detailTags" style="display: flex; flex-wrap: wrap; gap: 8px;">
                    <!-- Tags will be inserted here -->
                </div>
            </div>
            
            <button id="shopButton" style="width: 100%; padding: 15px; background: #0600ff; color: white; border: 2px solid #0600ff; font-family: 'Courier New', Courier, monospace; cursor: pointer; margin-bottom: 10px;">
                shop this item ‚Üí
            </button>
           
           
            <button onclick="closeImageDetail()" style="width: 100%; padding: 12px; background: #ccc; color: #000; border: 2px solid #999;">
                close
            </button>
        </div>
    </div>
</body>
</html>
